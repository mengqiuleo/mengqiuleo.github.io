[
  {
    "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4",
    "repository_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io",
    "labels_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4/comments",
    "events_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4/events",
    "html_url": "https://github.com/mengqiuleo/mengqiuleo.github.io/issues/4",
    "id": 2229121192,
    "node_id": "I_kwDOLqkdVs6E3bCo",
    "number": 4,
    "title": "奇怪的“bug”: JS数组解构赋值变量存在依赖关系",
    "user": {
      "login": "mengqiuleo",
      "id": 85825776,
      "node_id": "MDQ6VXNlcjg1ODI1Nzc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/85825776?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mengqiuleo",
      "html_url": "https://github.com/mengqiuleo",
      "followers_url": "https://api.github.com/users/mengqiuleo/followers",
      "following_url": "https://api.github.com/users/mengqiuleo/following{/other_user}",
      "gists_url": "https://api.github.com/users/mengqiuleo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mengqiuleo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mengqiuleo/subscriptions",
      "organizations_url": "https://api.github.com/users/mengqiuleo/orgs",
      "repos_url": "https://api.github.com/users/mengqiuleo/repos",
      "events_url": "https://api.github.com/users/mengqiuleo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mengqiuleo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 6788994123,
        "node_id": "LA_kwDOLqkdVs8AAAABlKfUSw",
        "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/labels/%E9%9A%8F%E6%84%8F%E8%B5%B7%E7%9A%84label",
        "name": "随意起的label",
        "color": "DFAD88",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2024-04-06T07:24:28Z",
    "updated_at": "2024-04-06T07:25:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "题目随便起的，这不是bug，而是自己对解构赋值理解不够深刻\r\n在刷力扣 41.缺失的第一个正数 这个题的时候，出现了解构赋值的问题，\r\n对于`[a,b] = [1,2]和[b,a]=[2,1]`按理说都是行的通的，和位置没有关系，本质上都是进行交换\r\n\r\n可是当我在题目中\r\n使用`[nums[nums[i]-1], nums[i]] = [nums[i], nums[nums[i]-1]]`时是可以通过测试用例的，\r\n使用`[nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]`会超时\r\n\r\n## 41. 缺失的第一个正数\r\n题目要求返回缺失的第一个正整数，那么我们可以采用“一个萝卜一个坑”的思想\r\n将数组中的所有数字归位，当下标为[0,N]时，数字应该为[1,N+1]\r\n那么数值为i的数应该放在下标为i-1的位置\r\n比如数字：`nums[i]`，它的下标应该为`nums[i]-1`，\r\n所以，反过来说，下标为`nums[i]-1`的地方对应的数字应该为`nums[nums[i]-1]`\r\n通过上面的推导，我们可以得出一个结论：`nums[nums[i]-1] === nums[i]`\r\n于是，我们可以遍历一遍，将所有的数组交换到正确的位置，然后再进行一次遍历，找到`nums[i] != i + 1`的数\r\n\r\n```javascript\r\nvar firstMissingPositive = function(nums) {\r\n    for(let i = 0; i < nums.length; i++){\r\n        while(nums[i] > 0 && nums[i] <= nums.length && nums[nums[i]-1] != nums[i] ){\r\n            // ok\r\n            const temp = nums[nums[i]-1]; \r\n            nums[nums[i]-1] = nums[i];\r\n            nums[i] = temp;\r\n\r\n            // const temp = nums[i];\r\n            // nums[i] = nums[nums[i]-1];\r\n            // nums[nums[i]-1] = temp;\r\n\r\n            // [nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]\r\n            // [nums[nums[i]-1], nums[i]] = [nums[i], nums[nums[i]-1]] ok\r\n        }\r\n    }\r\n    for(let i = 0; i < nums.length; i++){\r\n        if(nums[i] != i+1){\r\n            return i+1;\r\n        }\r\n    }\r\n    return nums.length + 1;\r\n};\r\n```\r\n但是，`[nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]`这样写是错的\r\n\r\n## 解释\r\n\r\n首先，清楚\r\n情况一：\r\n\r\n```javascript\r\nconst temp = nums[nums[i]-1]; \r\nnums[nums[i]-1] = nums[i];\r\nnums[i] = temp;\r\n\r\n// 等价于 \r\n\r\n[nums[nums[i]-1], nums[i]] = [nums[i], nums[nums[i]-1]]\r\n```\r\n情况二：\r\n\r\n```javascript\r\nconst temp = nums[i];\r\nnums[i] = nums[nums[i]-1];\r\nnums[nums[i]-1] = temp;\r\n\r\n// 等价于\r\n\r\n[nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]\r\n```\r\n情况一：\r\n对于情况一，\r\n我们先暂存了 `nums[nums[i]-1]`地址的值，然后更新`nums[nums[i]-1]`地址的值，\r\n因为此时`nums[i]`的值没有变，所以 `nums[nums[i]-1]`所指向的地址没有变，我们只是改变了该地址对应的值，\r\n最后更新`nums[i]`的值\r\n\r\n情况二：\r\n我们先暂存了`nums[i]`的值，然后更新`nums[i]`地址的值，当走到第三步更新`nums[nums[i]-1]`地址的值时，因为`nums[i]`的值发生了变化，那么相当于nums[nums[i]-1]这个地址发生了变化，最后我们将一个新地址的原有值改变了\r\n而我们的初衷是交换`nums[nums[i]-1]`和`nums[i]`这两个地址的值，结果我们改变了一个新地址的值\r\n\r\n\r\n## 画图模拟：\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8166e6bf42b74b168c52f428e3215a8e.jpeg#pic_center)\r\n\r\n## 解决：\r\n\r\n如果想让 `[nums[i], nums[nums[i]-1]] = [nums[nums[i]-1], nums[i]]`正确表示，\r\n可以这样：\r\n\r\n```javascript\r\nconst tmp = nums[i];\r\nnums[i] = nums[nums[i] - 1];\r\nnums[tmp -1] = tmp;\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/4/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3",
    "repository_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io",
    "labels_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3/comments",
    "events_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3/events",
    "html_url": "https://github.com/mengqiuleo/mengqiuleo.github.io/issues/3",
    "id": 2229120466,
    "node_id": "I_kwDOLqkdVs6E3a3S",
    "number": 3,
    "title": "从 axios 源码学习设计模式",
    "user": {
      "login": "mengqiuleo",
      "id": 85825776,
      "node_id": "MDQ6VXNlcjg1ODI1Nzc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/85825776?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mengqiuleo",
      "html_url": "https://github.com/mengqiuleo",
      "followers_url": "https://api.github.com/users/mengqiuleo/followers",
      "following_url": "https://api.github.com/users/mengqiuleo/following{/other_user}",
      "gists_url": "https://api.github.com/users/mengqiuleo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mengqiuleo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mengqiuleo/subscriptions",
      "organizations_url": "https://api.github.com/users/mengqiuleo/orgs",
      "repos_url": "https://api.github.com/users/mengqiuleo/repos",
      "events_url": "https://api.github.com/users/mengqiuleo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mengqiuleo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 6788987702,
        "node_id": "LA_kwDOLqkdVs8AAAABlKe7Ng",
        "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
        "name": "设计模式",
        "color": "c5def5",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2024-04-06T07:22:08Z",
    "updated_at": "2024-04-06T07:22:37Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "本篇文章并不会从0开始对 axios 进行分析，而是对 axios 的一些关键地方进行总结\r\n**另外，本篇大部分内容都是对一些现有文章的总结**\r\n参考文章：\r\n[Axios基本原理深度解析](https://juejin.cn/post/6844904199302430733#heading-4)\r\n\r\n# 一、源码分析\r\n## 1.1 axios 为什么可以多种方式调用\r\n首先，我们在使用Axios的时候，会有很多种用法。是怎么实现的呢？\r\naxios都能怎么调用\r\n\r\n```javascript\r\n// 第一种方法\r\naxios(config)\r\n// 第二种\r\naxios('example/url'[, config])\r\n// 第三种\r\naxios.request(config)\r\n// 第四种\r\naxios.get(url[, config])//'delete', 'get', 'head', 'options'请求方法一样的调用方式\r\n// 第五种\r\naxios.post(url[, data[, config]])// 'post', 'put', 'patch'请求方法永阳的调用方式\r\n// 第六种\r\naxios.all([axios1, axios2, axios3]).then(axios.spread(function (axios1response, axios2response, axios3response) {\r\n    // 三个请求现在都执行完成\r\n  }));\r\n// 还可以通过axios.create方法建立自定义全局默认配置的Axios实例\r\naxios.create(config)\r\n```\r\n\r\n\r\n总结有六种调用方式\r\n相关代码\r\n\r\n```javascript\r\nfunction createInstance(defaultConfig) {\r\n  // 建立Axios对象\r\n  var context = new Axios(defaultConfig);\r\n\r\n  // Axios作者的目的是提供一个对外可用的方法。\r\n  // 并且方法中需要用到Axios对象中的config属性和拦截器。\r\n  // 所以要把axios原型上的方法单独拿出来，绑定context这个axios实例。\r\n  // instance方法就是后面导出的axios实例，\r\n  // 所以到这里位置 第一种调用方法 axios(config) 就实现了\r\n  // 在request方法的内部，有对传入参数类型的判断，如果传入第一参数为字符串，则认为是url字符串，并且把url参数添加到第二个参数config中\r\n  // 所以就实现了第二种调用方法axios('example/url'[, config])\r\n  var instance = bind(Axios.prototype.request, context);\r\n\r\n  // 这里把Axios原型上的方法和属性，扩展到instance方法上，\r\n  // 并制定了原型上方法的this为context（上面定义axios对象）\r\n  // Axios上有request方法，这里绑定了this为context\r\n  // 所有第三种调用方法 axios.request(config) 就实现了\r\n  // Axios原型中其实定义了get，post，option等等方法，\r\n  // 所以第四种axios.get(url[, config])和第五种axios.post(url[, data[, config]])方法就实现了\r\n  utils.extend(instance, Axios.prototype, context);\r\n\r\n  // 这里把上面建立axios对象（context）中自有的属性方法，扩展到了instance中\r\n  // 这样instance就有了defaults、interceptors 属性，就可以添加拦截器，操作defaultConfig了\r\n  utils.extend(instance, context);\r\n\r\n  return instance;\r\n}\r\n\r\n// 调用createInstance方法，建立了Axios实例\r\nvar axios = createInstance(defaults);\r\n\r\n// 这里也调用上面的createInstance方法，同样建立了Axios实例，\r\n// 只不过，这里配置了自己的config作为全局默认的config\r\n// 所以这里实现了，通过axios.create方法建立自定义默认配置的Axios实例\r\naxios.create = function create(instanceConfig) {\r\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\r\n};\r\n\r\n// 这里添加了all方法，其实就是promise的all方法，\r\n// 这就是第六种调用方法，并发请求的实现原理\r\naxios.all = function all(promises) {\r\n  return Promise.all(promises);\r\n};\r\n// spread方法就是把用数组作为一个参数，变成数组的每一项为一个参数。就是为了用着方便。\r\naxios.spread = require('./helpers/spread');\r\n\r\nmodule.exports = axios;// 对外导出实例\r\n```\r\n\r\n\r\n上面注释中提到的第二种调用方法axios('example/url'[, config])的实现是request内部做了判断所以才能那么用。\r\n第四种axios.get(url[, config])和第五种axios.post(url[, data[, config]])方法的实现是因为Axios原型中定义了相应的方法，所以才得以实现。\r\n关于  Axios：\r\n\r\n```javascript\r\n// Axios构造函数，定义l额defaults属性和interceptors属性\r\nfunction Axios(instanceConfig) {\r\n  this.defaults = instanceConfig;\r\n  this.interceptors = {\r\n    request: new InterceptorManager(), //拦截器，后面会讲到\r\n    response: new InterceptorManager()\r\n  };\r\n}\r\n\r\nAxios.prototype.request = function request(config) {\r\n  // 这里对传入参数类型的判断，如果传入第一参数为字符串，\r\n  // 则认为字符串是url，并且把url参数添加到第二个参数config中\r\n  // 所以就实现了第二种调用方法axios('example/url'[, config])\r\n  if (typeof config === 'string') {\r\n    config = arguments[1] || {};\r\n    config.url = arguments[0];\r\n  } else {\r\n    config = config || {};\r\n  }\r\n\r\n  // ...省略了一些代码\r\n  }\r\n\r\n// 这里对Axios原型扩展了'delete', 'get', 'head', 'options'方法，\r\n// 其实都是调用了request方法\r\n// 结合上面lib / axios.js 代码中把原型中方法扩展到了instance上\r\n// 所以第四种方法axios.get(url[, config])就实现了\r\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\r\n  Axios.prototype[method] = function(url, config) {\r\n    return this.request(mergeConfig(config || {}, {\r\n      method: method,\r\n      url: url\r\n    }));\r\n  };\r\n});\r\n\r\n// 这里对Axios原型扩展了'post', 'put', 'patch'方法，\r\n// 其实都是调用了request方法\r\n// 结合上面lib / axios.js 代码中把原型中方法扩展到了instance上\r\n// 所以第五种方法axios.post(url[, data[, config]])就实现了\r\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\r\n  Axios.prototype[method] = function(url, data, config) {\r\n    return this.request(mergeConfig(config || {}, {\r\n      method: method,\r\n      url: url,\r\n      data: data\r\n    }));\r\n  };\r\n});\r\n```\r\n\r\n## 1.2 拦截器实现\r\n\r\n首先是如何使用的？\r\n请求拦截器是先加的后执行，响应是先加的先执行\r\n\r\n```javascript\r\n// 添加请求拦截器\r\nconst myRequestInterceptor = axios.interceptors.request.use(config => {\r\n    // 在发送http请求之前对config做点什么\r\n    return config; // 必须返回config否则后续http请求无法获取到config\r\n}, error => {\r\n    // 错误处理代码写在这里\r\n    \r\n    // 但是，为什么返回Promise.reject(error)\r\n    // 这和promise的机制有关\r\n    // 如果直接抛出error就相当于抛出一个对象，\r\n    // 这就会运行下一级promise的fulfilled方法。并且参数是error，这个fulfilled参数应该是config才对\r\n    // 或者运行到dispatchRequest，参数error，但dispatchRequest参数也要是config才对\r\n    return Promise.reject(error);\r\n});\r\n\r\n// 添加响应拦截器\r\naxios.interceptors.response.use(response => {\r\n  // 对响应数据处理代码写这里\r\n  return response; // 有且必须有一个response对象被返回\r\n}, error => {\r\n  // 对响应错误处理代码写这里\r\n  \r\n  // 同理请求拦截器，这需要返回Promise.reject(error);\r\n  return Promise.reject(error);\r\n});\r\n\r\n// 移除某次拦截器\r\naxios.interceptors.request.eject(myRequestInterceptor);\r\n```\r\n\r\n### 注册\r\n\r\naxios有interceptor属性，里面有两个属性request和response，都是InterceptorManager对象，目的是存储注册的拦截器。\r\n\r\n```javascript\r\nfunction Axios(instanceConfig) {\r\n  this.defaults = instanceConfig;\r\n  this.interceptors = {\r\n    request: new InterceptorManager(),\r\n    response: new InterceptorManager()\r\n  };\r\n}\r\n```\r\n\r\n那么InterceptorManager都做了什么呢，\r\n\r\n```javascript\r\n// 构造函数，在对象中定义handlers用来存储拦截器\r\nfunction InterceptorManager() {\r\n  this.handlers = [];\r\n}\r\n\r\n/**\r\n * 注册拦截器，并存储在handlers中\r\n * 参数fulfilled，用来拦截器处理数据的函数\r\n * 参数rejected，用来处理错误用的\r\n * 为什么这么设计，因为拦截器要通过Promise处理\r\n * 返回本条拦截器在数组handlers中的索引位置，以便提供给删除拦截器用\r\n */\r\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\r\n  this.handlers.push({\r\n    fulfilled: fulfilled,\r\n    rejected: rejected\r\n  });\r\n  return this.handlers.length - 1;\r\n};\r\n\r\n/**\r\n * 通过注册时候返回的拦截器索引来删除拦截器\r\n */\r\nInterceptorManager.prototype.eject = function eject(id) {\r\n  if (this.handlers[id]) {\r\n    this.handlers[id] = null;\r\n  }\r\n};\r\n/**\r\n * 遍历拦截器的方法\r\n */\r\nInterceptorManager.prototype.forEach = function forEach(fn) {\r\n  utils.forEach(this.handlers, function forEachHandler(h) {\r\n    if (h !== null) {\r\n      fn(h);\r\n    }\r\n  });\r\n};\r\n\r\n```\r\n注册完成了，那么怎么发挥作用呢，那就要看看request方法了。\r\n\r\n### 使用：promise链式调用\r\n\r\n```javascript\r\nvar dispatchRequest = require('./dispatchRequest');\r\n\r\nAxios.prototype.request = function request(config) {\r\n  // 刚进入方法，首先要处理config这里存放着http请求的必要配置\r\n  if (typeof config === 'string') {\r\n    config = arguments[1] || {};\r\n    config.url = arguments[0];\r\n  } else {\r\n    config = config || {};\r\n  }\r\n\r\n  config = mergeConfig(this.defaults, config);\r\n\r\n  // Set config.method\r\n  if (config.method) {\r\n    config.method = config.method.toLowerCase();\r\n  } else if (this.defaults.method) {\r\n    config.method = this.defaults.method.toLowerCase();\r\n  } else {\r\n    config.method = 'get';\r\n  }\r\n  // 到这里处理完用于http请求的配置数据config\r\n  \r\n  // 先定义个数组，先放入一个dispatchRequest和undefined，\r\n  // dispatchRequest前面的项目目录介绍里提到了，用来申请http请求用的\r\n  // 为什么先建立个数组呢，作者的目的就是想先把拦截器和http请求先排好序\r\n  // 然后再建立promise调用链，就可以一步一步的按顺序进行了\r\n  // 入果没有理解，建议先深入研究一下Promise链式调用\r\n  // 为什么先放dispatchRequest，又放个undefined呢\r\n  // 可以先看一下下面怎么向chain插入拦截器的\r\n  // 拦截器被插入到数组，并且一次向数组插入两个方法，interceptor.fulfilled, interceptor.rejected\r\n  // 再看看后面建立promise链式调用的时候，分别用在了then的两个参数，是从数组中一起取两个的\r\n  // 所以为了保证拦截器两个方法配对正确所以先插入[dispatchRequest, undefined]\r\n  // 之所以用undefined，因为这里没法处理错综复杂而且多变的错误。而且这里也只能用来处理请求拦截器的错误。所以没有必要。\r\n  // 所以用undefined，把错误抛到下面的promise，由用户定义处理方法。\r\n  var chain = [dispatchRequest, undefined];\r\n\r\n  // 先初始一个promise，value是config，\r\n  // 提供给下面的promise用，也就是提供给请求拦截器用\r\n  var promise = Promise.resolve(config);\r\n\r\n  // 向chain数组插入请求拦截器。一对一对的插入\r\n  // 注意这里是从前插入请求拦截器的\r\n  // 所以用的时候，先注册的请求拦截器是后执行的，这点要注意\r\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\r\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\n\r\n  // 向chain数组插入相应拦截器。一对一对的插入\r\n  // 相应拦截器是从后插入的\r\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\r\n    chain.push(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\n  // 到此，把拦截器和http请求拍好顺序了\r\n  // 下面就利用这个循序建立一个promise链\r\n  // promise链让拦截器和http请求按照顺序执行了，执行顺序是：\r\n  // 请求拦截器->http请求->相应拦截器\r\n  while (chain.length) {\r\n    promise = promise.then(chain.shift(), chain.shift());\r\n  }\r\n\r\n  return promise;\r\n};\r\n\r\n```\r\n\r\n到这里，已经建立了一个promise链。先执行请求拦截器，按照需求修改config。然后执行http请求。请求结果，传到相应拦截器处理。最后抛出链调用最后的promise，我们用这个promise就能得到这一串处理的最终结果了。\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cca70b2b44674045a295ef24616cad23.jpeg#pic_center)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94956e7ffb144204bb30c6887e47e674.jpeg#pic_center)\r\n<br/>\r\n# 二、从 axios 看设计模式\r\n\r\n## axios 的精髓在哪\r\n> 通过简单学习 axios 源码，就会发现，它的源码并不难，比 vue 要简单很多。 axios 的精髓在于他已经迭代了40个版本，\r\n> npm 的 version 规则是首个版本号变化表示 api 不向下兼容，现在 axios 的主版本号已经从 0.x 迭代到了 1.x, 按理说应该和 vue 一样，是有 重大变更的。 而 axios 增加了这么多功能。却始终保持没有 api 明显变化。主要原因是 axios 内部使用了多种设计模式和架构模式。\r\n>  比如 适配器，桥接，代理，抽象工厂，微内核设计，还有一些设计原则，axios里面都用的非常好。\r\n> 所以，当我们在用任何版本的 axios 除了一些 bug 以外，没有什么兼容问题。\r\n\r\n## 2.1 抽象工厂\r\n\r\n工厂模式将对象的创建和实现分离(尤其是写库的时候，经常需要把创建和实现进行分离)。\r\n使代码具备良好的封装性，可扩展性(符合开放封闭原则)，高解耦性(符合最少知识原则(说白了，就是让你能够傻瓜式应用))。\r\n\r\n> 为什么工厂模式返回的不是axios实例，而是axios.request?\r\n> 因为我们要进行封装，把实例给用户，体现我们工厂模式的优点。假如我们返回axios实例，就造成了无法传config了，这就很糟糕，所以我们返回了方法，就能传参数了。就能同时满足axios({})和axios.request({})\r\n妙啊\r\n\r\n```javascript\r\nimport Axios from './core/Axios';  // 引入Axios，是放axios的核心代码的\r\nimport { extend } from './helper/utils'; // 混入方法\r\n\r\n// 工厂\r\nfunction createInstance() {\r\n  const axios = new Axios();\r\n  const req = axios.request.bind(axios); //这里与源码有出入，但是意思一直，如果追求与源码的一致性，可以回头看看上面的源码分析部分\r\n  // req继承axios的属性和方法\r\n  // Object.getOwnPropertyNames(Axios.prototype)读取对象属性，可以读取不可不可遍历的属性\r\n  extend(req, Object.getOwnPropertyNames(Axios.prototype), axios);\r\n  extend(req, Object.getOwnPropertyNames(axios), axios);\r\n  return req;\r\n}\r\n\r\nconst axios = createInstance(); // 创建实例的工厂\r\nexport default axios;\r\n```\r\n\r\n### axios.create -- 创建新实例的工厂\r\n\r\naxios.create给用户提供了自定义配置的接口，通过调用mergeConfig()来合并用户配置和默认配置。从而我们可以得到一个自定义的instance\r\n\r\n```javascript\r\naxios.create = function create(instanceConfig) {\r\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\r\n};\r\n```\r\n\r\n<BR/>\r\n\r\n## 2.2 微内核设计\r\n\r\nAxios 是一个基于 Promise 的 HTTP 客户端库，它使用了微内核设计。微内核是一种软件设计模式，将核心功能与可选功能分离，通过插件机制实现灵活扩展。\r\n在 Axios 的源码中，它的微内核设计可以总结为以下几个主要的组件：\r\n1. 核心库：核心库提供了基本的请求和响应处理逻辑，包括创建 XMLHttpRequest 对象、设置请求配置、发送请求、处理响应等。它是 Axios 的核心部分，负责处理最基本的 HTTP 请求和响应。\r\n2. 拦截器：拦截器是一种插件机制，可以在请求和响应的过程中插入自定义的逻辑。Axios 通过 request 拦截器和 response 拦截器来实现请求和响应的拦截和修改。拦截器可以用于添加公共请求头、请求参数的处理、错误的全局处理等。\r\n3. 转换器：转换器允许你在发送请求之前或接收到响应之后对数据进行自定义转换。Axios 提供了请求和响应数据的转换器接口，可以通过设置 transformRequest 和 transformResponse 来定制数据的格式化和解析。\r\n4. 取消操作：Axios 允许你通过创建一个 CancelToken 实例来取消请求。取消请求可以通过 cancel 方法来触发，调用 cancel 方法后，Axios 将会中止该请求并抛出一个 Cancel 类型的错误。\r\n5. 错误处理：Axios 对错误的处理进行了统一的封装。它使用 Promise 的错误处理机制，当请求或响应发生错误时，会通过 Promise 的 reject 来返回错误信息。此外，Axios 也提供了全局的错误处理机制，你可以通过配置 onError 来捕获并处理全局的错误。\r\n6. 扩展机制：Axios 支持通过自定义适配器、拦截器、转换器等机制来扩展其功能。通过这些机制，你可以添加自定义的逻辑、处理非标准的返回数据类型、修改请求配置等。这使得 Axios 的功能非常灵活和可扩展。\r\n以上是 Axios 中微内核设计的主要组件和机制。这种设计使得 Axios 的核心库非常精简和高效，同时可以根据需求灵活地扩展和定制功能。\r\n\r\n首先 core 提供核心功能，然后各种功能：拦截器，错误处理，取消操作，转换器 都是重开一个文件夹，然后在 core 中进行引用\r\n\r\naxios 的 目录：\r\n\r\n```javascript\r\n├── /dist/                     # 项目输出目录\r\n├── /lib/                      # 项目源码目录\r\n│ ├── /cancel/                 # 定义取消功能\r\n│ ├── /core/                   # 一些核心功能\r\n│ │ ├── Axios.js               # axios的核心主类\r\n│ │ ├── dispatchRequest.js     # 用来调用http请求适配器方法发送请求\r\n│ │ ├── InterceptorManager.js  # 拦截器构造函数\r\n│ │ └── settle.js              # 根据http响应状态，改变Promise的状态\r\n│ ├── /helpers/                # 一些辅助方法\r\n│ ├── /adapters/               # 定义请求的适配器 xhr、http\r\n│ │ ├── http.js                # 实现http适配器\r\n│ │ └── xhr.js                 # 实现xhr适配器\r\n│ ├── axios.js                 # 对外暴露接口\r\n│ ├── defaults.js              # 默认配置 \r\n│ └── utils.js                 # 公用工具\r\n├── package.json               # 项目信息\r\n├── index.d.ts                 # 配置TypeScript的声明文件\r\n└── index.js                   # 入口文件\r\n```\r\n\r\n## 2.3 适配器思想\r\n\r\naxios 是 适配浏览器和node，兼容性，对外统一接口\r\naxios在浏览器端使用XMLHttpRequest对象发送ajax请求；在node环境使用http对象发送ajax请求。\r\n\r\n```javascript\r\nvar defaults.adapter = getDefaultAdapter();\r\nfunction getDefaultAdapter () {\r\n\tvar adapter;\r\n    if (typeof XMLHttpRequest !== 'undefined') {\r\n    \t// 浏览器环境\r\n        adapter = require('./adapter/xhr');\r\n    } else if (typeof process !== 'undefined') {\r\n    \t// node环境\r\n        adapter = require('./adapter/http');\r\n    }\r\n   return adapter;\r\n}\r\n```\r\n\r\n## 2.4 责任链模式\r\n\r\n> 一个链条，上面有很多职责。\r\n> 他的好处是链条上的各个职责，只需要关心自己的事情就行了，不需要知道自己的上一步是什么，下一步是什么，跟上下的职责都不耦合，这样当上下职责变化了，自己也不受影响，往链条上添加或者减少职责也非常方便。\r\n\r\n\r\nAxios的拦截器有请求拦截器和响应拦截器，执行的顺序是请求拦截器 -> 发起请求 -> 响应拦截器，这其实就是一个链条上串起了三个职责。\r\n\r\n```javascript\r\n// 先从用法入手，一般我们添加拦截器是这样写的 \r\n// instance.interceptors.request.use(fulfilled, rejected)\r\n// 根据这个用法我们先写一个Axios类。\r\nfunction Axios() {\r\n  // 实例上有个interceptors对象，里面有request和response两个属性\r\n  // 这两个属性都是InterceptorManager的实例\r\n  this.interceptors = {\r\n    request: new InterceptorManager(),\r\n    response: new InterceptorManager()\r\n  };\r\n}\r\n\r\n// 然后是实现InterceptorManager类\r\nfunction InterceptorManager() {\r\n  // 实例上有一个数组，存储拦截器方法\r\n  this.handlers = [];\r\n}\r\n\r\n// InterceptorManager有一个实例方法use\r\nInterceptorManager.prototype.use = function(fulfilled, rejected) {\r\n  // 这个方法很简单，把传入的回调放到handlers里面就行\r\n  this.handlers.push({\r\n    fulfilled,\r\n    rejected\r\n  })\r\n}\r\n```\r\n这些拦截器方法都是什么时候执行呢？当然是我们调用instance.request的时候，调用instance.request的时候真正执行的就是请求拦截器 -> 发起请求 -> 响应拦截器链条，所以我们还需要来实现下Axios.prototype.request:\r\n\r\n```javascript\r\nAxios.prototype.request = function(config) {\r\n  // chain里面存的就是我们要执行的方法链条\r\n  // dispatchRequest是发起网络请求的方法，本文主要讲设计模式，这个方法就不实现了\r\n  // chain里面先把发起网络请求的方法放进去，他的位置应该在chain的中间\r\n  const chain = [dispatchRequest, undefined];\r\n  \r\n  // chain前面是请求拦截器的方法,从request.handlers里面取出来放进去\r\n  this.interceptors.request.handlers.forEach(function unshiftRequestInterceptors(interceptor) {\r\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\n  \r\n  // chain后面是响应拦截器的方法，从response.handlers里面取出来放进去\r\n  this.interceptors.response.handlers.forEach(function pushResponseInterceptors(interceptor) {\r\n    chain.push(interceptor.fulfilled, interceptor.rejected);\r\n  });\r\n  \r\n  // 经过上述代码的组织，chain这时候是这样的：\r\n  // [request.fulfilled, request.rejected, dispatchRequest, undefined, response.fulfilled,  \r\n  // response.rejected]\r\n  // 这其实已经按照请求拦截器 -> 发起请求 -> 响应拦截器的顺序排好了，拿来执行就行\r\n  \r\n  let promise = Promise.resolve(config);   // 先来个空的promise，好开启then\r\n  while (chain.length) {\r\n    // 用promise.then进行链式调用\r\n    promise = promise.then(chain.shift(), chain.shift());\r\n  }\r\n\r\n  return promise;\r\n}\r\n```\r\n\r\n注意，请求拦截器用了 unshift 方法，响应拦截器用了 push 方法\r\n是因为：**请求拦截器是先加的后执行，响应是先加的先执行**\r\n\r\n\r\n## 2.5 桥接模式\r\n\r\n> 首先，什么是桥接模式，它主要是优化不同维度，从 3*3 变成 3+1\r\n> 桥接模式是一种结构设计模式，用于将抽象部分和其实现部分解耦，并使它们能够独立地变化。它通过将抽象部分与实现部分之间建立一个桥接（Bridge）来实现解耦。\r\n\r\n\r\n\r\n桥接模式人如其名，其实就相当于一个桥梁，把不同维度的变量桥接在一起来实现功能。假设我们需要实现三种形状（长方形，圆形，三角形），每种形状有三种颜色（红色，绿色，蓝色），这个需求有两个方案，一个方案写九个方法，每个方法实现一个图形：\r\n\r\n```javascript\r\nfunction redRectangle() {}\r\nfunction greenRectangle() {}\r\nfunction blueRectangle() {}\r\nfunction redCircle() {}\r\nfunction greenCircle() {}\r\nfunction blueCircle() {}\r\nfunction redTriangle() {}\r\nfunction greenTriangle() {}\r\nfunction blueTriangle() {}\r\n```\r\n\r\n上述代码虽然功能实现了，但是如果我们需求变了，我们要求再加一个颜色，那我们就得再加三个方法，每个形状加一个。这么多方法看着就很重复，意味着他有优化的空间。我们仔细看下这个需求，我们最终要画的图形有颜色和形状两个变量，这两个变量其实是没有强的逻辑关系的，完全是两个维度的变量。那我们可以将这两个变量拆开，最终要画图形的时候再桥接起来，就是这样：\r\n\r\n```javascript\r\nfunction rectangle(color) {     // 长方形\r\n  showColor(color);\r\n}\r\n\r\nfunction circle(color) {     // 圆形\r\n  showColor(color);\r\n}\r\n\r\nfunction triangle(color) {   // 三角形\r\n  showColor(color);\r\n}\r\n\r\nfunction showColor(color) {   // 显示颜色的方法\r\n  \r\n}\r\n\r\n// 使用时，需要一个红色的圆形\r\nlet obj = new circle('red');\r\n```\r\n使用桥接模式后我们的方法从3 * 3变成了3 + 1，而且如果后续颜色增加了，我们只需要稍微修改showColor方法，让他支持新颜色就行了。如果我们变量的维度不是2，而是3，这种优势会更加明显，前一种需要的方法是x * y * z个，桥接模式优化后是x + y + z个，这直接就是指数级的优化。所以这里桥接模式优化的核心思想是观察重复代码能不能拆成多个维度，如果可以的话就把不同维度拆出来，使用时再将这些维度桥接起来。\r\n\r\n### 举例：\r\n\r\n桥接模式其实最形象的例子就是毛笔和蜡笔，因为这个例子非常直观，好理解。这个例子的需求是要画细，中,粗三种型号的线，每种型号的线需要5种颜色，如果我们用蜡笔来画就需要15支蜡笔，如果我们换毛笔来画，只需要3支毛笔就行了，每次用不同颜色的墨水，用完换墨水就行。写成代码就是这样，跟上面那个有点像:\r\n\r\n```javascript\r\n// 先来三个笔的类\r\nfunction smallPen(color) {\r\n  this.color = color;\r\n}\r\nsmallPen.prototype.draw = function() {\r\n  drawWithColor(this.color);    // 用color颜色来画画\r\n}\r\n\r\nfunction middlePen(color) {\r\n  this.color = color;\r\n}\r\nmiddlePen.prototype.draw = function() {\r\n  drawWithColor(this.color);    // 用color颜色来画画\r\n}\r\n\r\nfunction bigPen(color) {\r\n  this.color = color;\r\n}\r\nbigPen.prototype.draw = function() {\r\n  drawWithColor(this.color);    // 用color颜色来画画\r\n}\r\n\r\n// 再来一个颜色类\r\nfunction color(color) {\r\n  this.color = color;\r\n}\r\n\r\n// 使用时\r\nnew middlePen(new color('red')).draw();    // 画一个中号的红线\r\nnew bigPen(new color('green')).draw();     // 画一个大号的绿线\r\n\r\n```\r\n\r\n\r\n### 对于 axios来说：\r\n\r\n在 Axios 中，抽象部分可以被看作是对 HTTP 请求的封装，而实现部分则表示不同平台或环境下的具体实现方式，例如浏览器环境和 Node.js 环境。\r\nAxios 通过提供统一的 API 接口，将不同平台下的 HTTP 请求细节抽象出来，使得开发者可以使用相同的代码来发送请求，而无需关心底层实现的差异。\r\n比如，我们需要发送 get、post 请求，并且需要在 浏览器 和 node 端运行，那么本来是 `2*2`\r\n而对 get、post 请求统一封装，将它变成 1，那么此时就变成了 `1*2`\r\n我们可以看到无论是发送 GET 请求还是 POST 请求，使用的都是相同的 axios 对象和函数调用方式。这使得开发者可以在不同的平台和环境下保持一致的编码风格和API调用方式。\r\nAxios 库内部根据当前运行环境的不同，会选择合适的实现方式来发送 HTTP 请求，例如在浏览器环境中使用 XMLHttpRequest 或 Fetch API，在 Node.js 环境中使用基于 HTTP 模块或第三方库如 http 或 https。\r\n通过这种设计，Axios 实现了抽象部分（HTTP 请求）与实现部分（底层网络传输）之间的解耦，使得开发者可以专注于业务逻辑而无需关心底层实现细节，体现了类似于桥接模式的设计思想。\r\n\r\n\r\n\r\n### 桥接模式和适配器模式有什么区别\r\n\r\n桥接模式（Bridge Pattern）和适配器模式（Adapter Pattern）虽然在某些方面有一些相似之处，但它们在设计目的和实现方式上有着明确的区别。\r\n\r\n1. 设计目的：\r\n● 桥接模式的设计目的是将抽象部分与实现部分分离，使它们可以独立变化。桥接模式主要关注如何通过组合来实现不同维度的变化。它的目标是减少抽象和实现之间的耦合，提供更灵活的扩展性。\r\n● 适配器模式的设计目的是在不兼容的接口之间进行适配，使它们能够一起工作。适配器模式主要关注如何通过转换接口来实现不同接口之间的协同工作。它的目标是提供接口转换，以实现两个不兼容接口之间的适配。\r\n2. 功能和用途：\r\n● 桥接模式通过将抽象部分和实现部分分开，允许它们可以独立变化。桥接模式可以在两个维度上进行变化，例如在多个平台上实现多个颜色的图形。\r\n● 适配器模式主要用于两个不兼容接口之间的协同工作。适配器模式用于兼容两个不同接口，使它们能够一起工作。\r\n桥接模式 是 二维 的，适配器模式是 一维 的。\r\n3. 关注的对象：\r\n● 桥接模式关注的是如何将抽象部分和实现部分分离，并让它们可以独立变化。它关注的是系统的结构层面。\r\n● 适配器模式关注的是两个不兼容接口之间的适配，使它们能够一起工作。它关注的是接口之间的协同工作。\r\n4. 实现方式：\r\n● 桥接模式通过将抽象部分和实现部分分开，并通过组合的方式实现不同维度的变化。抽象部分和实现部分可以独立扩展而不会相互影响。\r\n● 适配器模式通常通过包装或继承来转换接口，使两个接口能够一起工作。适配器模式兼容已有的代码，通过适配器来调用原有接口，以实现两个接口之间的协同工作。\r\n\r\n总结起来，桥接模式主要关注在抽象部分和实现部分之间的分离和独立变化，而适配器模式主要关注两个不兼容接口之间的适配和协同工作。它们在设计目的、功能和实现方式上有明显的差异。",
    "reactions": {
      "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/3/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2",
    "repository_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io",
    "labels_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2/comments",
    "events_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2/events",
    "html_url": "https://github.com/mengqiuleo/mengqiuleo.github.io/issues/2",
    "id": 2229119751,
    "node_id": "I_kwDOLqkdVs6E3asH",
    "number": 2,
    "title": "浏览器初渲染/更新过程",
    "user": {
      "login": "mengqiuleo",
      "id": 85825776,
      "node_id": "MDQ6VXNlcjg1ODI1Nzc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/85825776?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mengqiuleo",
      "html_url": "https://github.com/mengqiuleo",
      "followers_url": "https://api.github.com/users/mengqiuleo/followers",
      "following_url": "https://api.github.com/users/mengqiuleo/following{/other_user}",
      "gists_url": "https://api.github.com/users/mengqiuleo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mengqiuleo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mengqiuleo/subscriptions",
      "organizations_url": "https://api.github.com/users/mengqiuleo/orgs",
      "repos_url": "https://api.github.com/users/mengqiuleo/repos",
      "events_url": "https://api.github.com/users/mengqiuleo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mengqiuleo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 6788983646,
        "node_id": "LA_kwDOLqkdVs8AAAABlKerXg",
        "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/labels/%E6%B5%8F%E8%A7%88%E5%99%A8",
        "name": "浏览器",
        "color": "0e8a16",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2024-04-06T07:19:49Z",
    "updated_at": "2024-04-06T07:20:42Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "之前阅读过李兵老师的《浏览器工作原理与实践》，但还是对其中有些概念模糊，于是趁着国庆，对浏览器渲染更新原理进行梳理。\r\n**注：本篇只是对一些优秀资料的总结及自己的理解，并非作者原创**！！！\r\n如果时间充裕建议阅读本文最后的引用。\r\n\r\n\r\n先放图：\r\n![](https://img-blog.csdnimg.cn/img_convert/a38c719cc2e0cbe19532256021648b54.png)\r\n\r\n<a name=\"zEnnV\"></a>\r\n## 帧维度解释帧渲染过程\r\n在一个流畅的页面变化效果中（动画或滚动），**渲染帧**，指的是浏览器从js执行到paint的一次绘制过程，帧与帧之间快速地切换，由于人眼的残像错觉，就形成了动画的效果。那么这个“快速”，要达到多少才合适呢？\r\n我们都知道，下层建筑决定了上层建筑。受限于目前大多数屏幕的刷新频率——**60次/s**，浏览器的渲染更新的页面的**标准帧率**也为**60次/s**--**60FPS**(frames/per second)。\r\n\r\n- 高于这个数字，在一次屏幕刷新的时间间隔**16.7ms**(1/60)内，就算浏览器渲染了多次页面，屏幕也只刷新一次，这就造成了性能的浪费。\r\n- 低于这个数字，帧率下降，人眼就可能捕捉到两帧之间变化的滞涩与突兀，表现在屏幕上，就是页面的抖动，大家通常称之为**卡顿**\r\n\r\n来个比喻。快递每天整理包裹，并一天一送。如果某天包裹太多，整理花费了太多时间，来不及当日（帧）送到收件人处，那就延期了（丢帧）。\r\n**标准渲染帧：**\r\n![v2-e893a683add1fe8e77e6e6d7676e2662_720w.png](https://img-blog.csdnimg.cn/img_convert/2d510f02f5064575f8a002eb30426deb.png)\r\n在一个标准帧渲染时间16.7ms之内，浏览器需要完成Main线程的操作，并commit给Compositor进程\r\n**丢帧：**\r\n![](https://img-blog.csdnimg.cn/img_convert/18b0223eaa80a089a9bd2768894fcbff.png)\r\n主线程里操作太多，耗时长，commit的时间被推迟，浏览器来不及将页面draw到屏幕，这就丢失了一帧\r\n\r\n<a name=\"VJNQc\"></a>\r\n## 一些名词解释\r\n<a name=\"p3C4e\"></a>\r\n### Renderer进程\r\n\r\n- Main线程：浏览器渲染的主要执行步骤，包含从JS执行到Composite合成的一系列操作。负责解析html css 和主线程中的js，我们平时熟悉的那些东西，诸如：Calculate Style,Update Layer Tree,Layout,Paint,Composite Layers等等都是在这个线程中进行的。 总之，就是将我们的代码解析成各种数据，直到能被合成器线程接收去做处理。\r\n- Compositor(合成)线程：\r\n   1. 接收一个vsync信号，表示这一帧开始\r\n   2. 接收用户的一些交互操作(比如滚动)  ，然后commit给Main线程\r\n   3. 唤起Main线程进行操作 \r\n   4. 接收Main线程的操作结果 \r\n   5. 将图层划分为图块（tile），并交给栅格化线程\r\n   6. 拿到栅格化线程的执行结果，它的结果就是一些位图\r\n   7. commit给真正把页面draw到屏幕上的GPU进程\r\n- Compositor Tile Work(s)线程：Compositor调起Compositor Tile Work(s)来辅助处理页面。Rasterize意为光栅化。这里的 Tile 其实就是位图的意思(下文会详细说明)，合成线程会将图层划分为图块（tile），生成位图的操作是由栅格化来执行的。栅格化线程不止一个，可能有多个栅格化线程。\r\n\r\n<a name=\"Ku3Vf\"></a>\r\n### GPU进程\r\n整个浏览器共用一个。主要是负责把Renderer进程中绘制好的tile位图作为纹理上传至GPU，并调用GPU的相关方法把纹理draw到屏幕上。GPU进程里只有一个线程：GPU Thread。\r\n这里其实只需要知道：GPU进程把 render进程的结果 draw 到 页面上。\r\n\r\n<a name=\"Es7sm\"></a>\r\n### rendering(渲染) vs painting(绘制)⭐\r\n这里的 painting 也可以理解成上面的 draw，火焰图中也会出现这两个关键词。\r\n![Snipaste_2023-10-01_17-14-56.jpg](https://img-blog.csdnimg.cn/img_convert/b4dcb233ab2bc205ed4f7038df0195fe.jpeg)\r\n我们可以想象成 除了浏览器之外，还有一个后台工人，浏览器使用双缓冲，始终有两张图\r\n\r\n- rendering 渲染：后台工人画的过程，这里就是 浏览器的render进程\r\n- painting 绘制：当后台工人画好后往浏览器页面上放的过程，GPU进程负责将画好的东西paint(draw)到浏览器上\r\n\r\n![Snipaste_2023-09-28_22-51-36.jpg](https://img-blog.csdnimg.cn/img_convert/0c062a0796665de796e2e5dd59c544e4.jpeg)\r\n\r\n后台工人先render一张，render完毕后，把浏览器的那张图替换下来叫paint(draw)，然后后台工人又开始在替换下来的那张图上进行render\r\n浏览器每一帧会替换一次，保证动画是连续的，很像动画那样一帧一帧\r\n\r\n\r\n<a name=\"CixiE\"></a>\r\n### 位图\r\n![](https://img-blog.csdnimg.cn/img_convert/b41147dcfaff133cda587267ac9e83f6.webp?x-oss-process=image/format,png)\r\n就是数据结构里常说的位图。你想在绘制出一个图片，你应该怎么做，显然首先是把这个图片表示为一种计算机能理解的数据结构：用一个二维数组，数组的每个元素记录这个图片中的每一个像素的具体颜色。所以浏览器可以用位图来记录他想在某个区域绘制的内容，绘制的过程也就是往数组中具体的下标里填写像素而已。\r\n\r\n<a name=\"wOP9H\"></a>\r\n### 纹理\r\n纹理其实就是GPU中的位图，存储在GPU video RAM中。前面说的位图里的元素存什么你自己定义好就行，是用3字节存256位rgb还是1个bit存黑白你自己定义即可，但是纹理是GPU专用的，GPU和CPU是分离的，需要有固定格式，便于兼容与处理。所以一方面纹理的格式比较固定，如R5G6B5、A4R4G4B4等像素格式， 另外一方面GPU 对纹理的大小有限制，比如长/宽必须是2的幂次方，最大不能超过2048或者4096等。\r\n\r\n总结：render进程中的叫位图，GPU进程中的叫纹理，生成位图(纹理)的这个过程叫栅格化，ok，过...\r\n\r\n<a name=\"oTIa0\"></a>\r\n\r\n### Rasterize(光栅化)\r\n![](https://img-blog.csdnimg.cn/img_convert/a84762a0a8bcc8c657a7ed1c8cf14331.webp?x-oss-process=image/format,png)\r\n![](https://img-blog.csdnimg.cn/img_convert/f3eb7cb43e9599db2558fea2491d36be.webp?x-oss-process=image/format,png)\r\n\r\n在纹理里填充像素不是那么简单的自己去遍历位图里的每个元素然后填写这个像素的颜色的。就像前面两幅图。**光栅化的本质是坐标变换、几何离散化，然后再填充**。\r\n同时，光栅化从早期的 Full-screen Rasterization基本都进化到了现在的Tile-Based Rasterization， 也就是不是对整个图像做光栅化，而是把图像分块(tile，亦有翻译为瓦片、贴片、瓷片…)后，再对每个tile单独光栅化。光栅化好了将像素填充进纹理，再将纹理上传至GPU。\r\n原因一方面如上文所说，纹理大小有限制，即使你整屏光栅化也是要填进小块小块的纹理中，不如事先根据纹理大小分块光栅化后再填充进纹理里。另一方面是为了减少内存占用(整屏光栅化意味着需要准备更大的buffer空间)和降低总体延迟（分块栅格化意味着可以多线程并行处理）。\r\n看到下图中蓝色的那些青色的矩形了吗？他们就是tiles。\r\n![](https://img-blog.csdnimg.cn/img_convert/846a9a7e8859a798525b47c18bd9cf7b.webp?x-oss-process=image/format,png)\r\n可以想见浏览器的一次绘制过程就是先把想绘制的内容如文字、背景、边框等通过分块Rasterize绘制到很多纹理里，再把纹理上传到gpu的存储空间里，gpu把纹理绘制到屏幕上。\r\n上面balabala说了一大堆，看得懂就看，看不懂就直接看总结...\r\n**所以，什么是光栅化**，光栅化本质也是生成位图(纹理)，不过会先分块，然后对每一块进行生成位图，这个分块的过程是由合成线程实现的，生成位图的过程是栅格化线程实现的。为什么要先分块，再栅格化，而不直接对整块屏幕做栅格化？为了减少内存占用和多线程处理(那这就意味着栅格化线程不止一个，可能有多个栅格化线程)。\r\n\r\n\r\n名词解释完了，开始详细介绍浏览器渲染的每一步。再次摆出整个渲染流程图。\r\n![](https://img-blog.csdnimg.cn/img_convert/a38c719cc2e0cbe19532256021648b54.png)\r\n或者另外一张类似的流程图\r\n![9411794cdd8fcb055db322d71dcd8f17~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp](https://img-blog.csdnimg.cn/img_convert/c84f8a6040d1995499ae4dc309d80d41.webp?x-oss-process=image/format,png)\r\n\r\n<a name=\"a9TX4\"></a>\r\n## 1. 浏览器的某一帧开始：vsync\r\nCompositor(合成)线程接收一个vsync信号，表示这一帧开始\r\n\r\n\r\n<a name=\"cMRHt\"></a>\r\n## 2. Input event handlers\r\nCompositor线程接收用户的交互输入（比如touchmove、scroll、click等）。然后commit给Main线程，这里有两点规则需要注意：\r\n\r\n- 并不是所有event都会commit给Main线程，部分操作比如单纯的滚动事件，打字等输入，不需要执行JS，也没有需要重绘的场景，Compositor线程就自己处理了，无需请求Main线程\r\n- 同样的事件类型，不论一帧内被Compositor线程接收多少次，实际上commit给Main线程的，只会是一次，意味着也只会被执行一次。（HTML5标准里scroll事件是每帧触发一次），所以自带了相对于动画的节流效果！**scroll、resize、touchmove、mousemove等事件，由于Compositor Thread的机制原因，都会每一帧只执行一次**\r\n\r\n\r\n<a name=\"r1O6H\"></a>\r\n## 3. requestAnimationFrame\r\nwindow.requestAnimationFrame() 这个方法，既然已经说明了它是一个方法，那它一定是在 JavaScript 中执行的。\r\n\r\n\r\n<a name=\"J6Sj1\"></a>\r\n## 4. 强制重排(可能存在)\r\n[Avoid large, complex layouts and layout thrashing](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/)\r\n下面对这个引用文章进行解释：\r\n这里本来已经走到了我们熟知的浏览器渲染过程：\r\njs修改dom结构或样式 -> 计算style -> layout(重排) -> paint(重绘) -> composite(合成)\r\n首先运行 JavaScript，然后运行样式计算，最后运行布局。然而，可以使用 JavaScript 强制浏览器提前执行布局。这称为强制同步布局。\r\n接下来解释 强制重排，也叫强制同步布局。\r\n首先要记住的是，当 JavaScript 运行时，前一帧中的所有旧布局值都是已知的，可供您查询。因此，例如，如果您想在帧的开头写出元素（我们称之为“盒子”）的高度，您可以编写如下代码：\r\n```css\r\n// Schedule our function to run at the start of the frame:\r\nrequestAnimationFrame(logBoxHeight);\r\n\r\nfunction logBoxHeight () {\r\n  // Gets the height of the box in pixels and logs it out:\r\n  console.log(box.offsetHeight);\r\n}\r\n```\r\n如果您在询问框的高度_之前_更改了框的样式，则会出现问题：\r\n```css\r\nfunction logBoxHeight () {\r\n  box.classList.add('super-big');\r\n\r\n  // Gets the height of the box in pixels and logs it out:\r\n  console.log(box.offsetHeight);\r\n}\r\n```\r\n现在，为了回答高度问题，浏览器必须_首先_应用样式更改（因为添加了super-big类），_然后_运行布局。只有这样它才能返回正确的高度。这是不必要且可能昂贵的工作。这就是强制重排。\r\n> **强制重排**意思是可能会在JS里强制重排，当访问scrollWidth系列、clientHeight系列、offsetTop系列、ComputedStyle等属性时，会触发这个效果，导致Style和Layout前移到JS代码执行过程中\r\n\r\n浏览器有自己的优化机制，包括之前提到的每帧只响应同类别的事件一次，再比如这里的会把一帧里的多次重排、重绘汇总成一次进行处理。\r\n**flush队列**是浏览器进行重排、重绘等操作的队列，所有会引起重排重绘的操作都包含在内，比如dom修改、样式修改等。如果每次js操作都去执行一次重排重绘，那么浏览器一定会卡卡卡卡卡，所以浏览器通常是**在一定的时间间隔（一帧）内，批量处理队列里的操作**。但是，对于有些操作，比如获取元素相对父级元素左边界的偏移值（Element.offsetLeft），但在此之前我们进行了样式或者dom修改，这个操作还攒在flush队列里没有执行，那么浏览器为了让我们获取正确的offsetLeft（虽然之前的操作可能不会影响offsetLeft的值），就会立即执行队列里的操作。\r\n![Snipaste_2023-10-01_09-26-23.jpg](https://img-blog.csdnimg.cn/img_convert/3568adc3e1ca78e99cbe06ba10071f70.jpeg)\r\n所以我们知道了，就是这个特殊操作会影响浏览器正常的执行和渲染，假设我们频繁执行这样的特殊操作，就会打断浏览器原来的节奏，增大开销。\r\n而这个特殊操作，具体指的就是：\r\n\r\n- elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent\r\n- elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight\r\n- elem.getClientRects(), elem.getBoundingClientRect()\r\n- elem.scrollWidth, elem.scrollHeight\r\n- elem.scrollLeft, elem.scrollTop\r\n- ...\r\n\r\n更多会触发强制重排的属性：[See more：What forces layout / reflow](https://link.zhihu.com/?target=https%3A//gist.github.com/paulirish/5d52fb081b3570c81e3a)\r\n\r\n\r\n\r\n<a name=\"B1y4s\"></a>\r\n## 5. parse HTML(构建DOM树)\r\n如果有DOM变动，那么会有解析DOM的这一过程。\r\n![125849ec56a3ea98d4b476c66c754f79.webp](https://img-blog.csdnimg.cn/img_convert/bb543328d56417bc529c2ee86437965d.webp?x-oss-process=image/format,png)\r\n\r\n\r\n\r\n<a name=\"rGcBT\"></a>\r\n## 6. 计算样式\r\n样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成\r\n<a name=\"ObsSC\"></a>\r\n### 6.1 把CSS转换为浏览器能够理解的结构\r\n那CSS样式的来源主要有哪些呢？你可以先参考下图：\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/f6213e223002a81d78f9cb8ba30534cc.png)\r\n从图中可以看出，CSS样式来源主要有三种：\r\n\r\n- 通过link引用的外部CSS文件\r\n- `<style>` 标记内的 CSS\r\n- 元素的style属性内嵌的CSS\r\n- 和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets。\r\n- 为了加深理解，你可以在Chrome控制台中查看其结构，只需要在控制台中输入document.styleSheets，然后就看到如下图所示的结构\r\n\r\n![](https://img-blog.csdnimg.cn/img_convert/1a96407159ea49f8a5aa2c81ee8f1950.png)\r\n从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的CSS文本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础\r\n<a name=\"JDQza\"></a>\r\n### 6.2 转换样式表中的属性值，使其标准化\r\n现在我们已经把现有的CSS文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。\r\n要理解什么是属性值标准化，你可以看下面这样一段CSS文本\r\n```css\r\nbody { font-size: 2em }\r\np {color:blue;}\r\nspan  {display: none}\r\ndiv {font-weight: bold}\r\ndiv  p {color:green;}\r\ndiv {color:red; }\r\n```\r\n可以看到上面的CSS文本中有很多属性值，如2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。\r\n那标准化后的属性值是什么样子的？\r\n![](https://img-blog.csdnimg.cn/img_convert/d960745965fa505929a8f04568cdca2b.png)\r\n从图中可以看到，2em被解析成了32px，red被解析成了rgb(255,0,0)，bold被解析成了700……\r\n<a name=\"bk0m7\"></a>\r\n### 6.3 计算出DOM树中每个节点的具体样式\r\n现在样式的属性已被标准化了，接下来就需要计算DOM树中每个节点的样式属性了，如何计算呢？\r\n**这就涉及到CSS的继承规则和层叠规则了。**\r\n首先是CSS继承。CSS继承就是每个DOM节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到DOM节点上的\r\n\r\n```css\r\nbody { font-size: 20px }\r\np {color:blue;}\r\nspan  {display: none}\r\ndiv {font-weight: bold;color:red}\r\ndiv  p {color:green;}\r\n```\r\n这张样式表最终应用到DOM节点的效果如下图所示：\r\n![](https://img-blog.csdnimg.cn/img_convert/de5a285ecaaeedfa65cf14b05492dee4.png)\r\n从图中可以看出，所有子节点都继承了父节点样式。比如body节点的font-size属性是20，那body节点下面的所有节点的font-size都等于20。\r\n为了加深你对CSS继承的理解，你可以打开Chrome的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面\r\n![](https://img-blog.csdnimg.cn/img_convert/50c498f96eaa6a024915a94491ee8fe8.png)\r\n这个界面展示的信息很丰富，大致可描述为如下\r\n\r\n- 首先，可以选择要查看的元素的样式（位于图中的区域2中），在图中的第1个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是<p>标签，位于html.body.div.这个路径下面\r\n- 其次，可以从样式来源（位于图中的区域3中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于UserAgent样式表。这里需要特别提下UserAgent样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是UserAgent样式。\r\n- 最后，可以通过区域2和区域3来查看样式继承的具体过程。\r\n\r\n以上就是CSS继承的一些特性，样式计算过程中，会根据DOM节点的继承关系来合理计算节点样式。\r\n样式计算过程中的第二个规则是样式层叠。**层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法**。它在CSS处于核心地位，CSS的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习\r\n总之，样式计算阶段的目的是为了计算出DOM节点中每个元素的具体样式，在计算过程中需要遵守CSS的继承和层叠两个规则。这个阶段最终输出的内容是每个DOM节点的样式，并被保存在ComputedStyle的结构内。\r\n\r\n\r\n<a name=\"XSEh7\"></a>\r\n## 7. 构建Render Tree(渲染树)的流程：\r\n\r\n1. 从DOM树的根开始，遍历每个可见节点。\r\n   1. 一些节点不可见（例如，脚本标签，meta标签等），由于它们未反映在输出中，因此将其省略。\r\n   2. 一些节点通过CSS隐藏，在渲染树中也被省略。注意visibility: hidden有所不同于display: none。\r\n2. 对于每个可见节点，找到合适的CSSOM规则并应用它们。\r\n3. 输出每个可见节点具有的内容及其样式。\r\n\r\n![16f040b792504d43~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp](https://img-blog.csdnimg.cn/img_convert/fdc151ace6dfdce6e2ec11c520da2a36.webp?x-oss-process=image/format,png)\r\n最终产出一个Render Tree，其中包含屏幕上所有可见内容的内容和样式信息。\r\n浏览器已经计算了哪些节点应该可见以及它们的样式，但是还没有计算它们在设备视口中的确切位置和大小，这是layout阶段该做的事，也称为“重排”\r\nRender Tree中储存节点渲染信息的对象叫做**Render Object**（这个概念需要留意，下面会用到）\r\n<a name=\"UZscn\"></a>\r\n## 8. Layout(重排reflow)，构建布局树\r\n我们已经知道了DOM节点的大小，但是还不知道它在页面上的具体位置，这一步就是构建布局树，也叫重排。\r\n主线程遍历Render Tree，并创建布局树，该树具有诸如xy坐标和边界框大小之类的信息。布局树的结构可能与DOM树类似，但它仅包含与页面上可见内容有关的信息。如果应用display: none，则该元素不属于布局树（但是，具有visibility: hidden的元素在布局树中）。同样，如果应用了具有类似的伪类p::before{content:\"Hi!\"}，则即使它不在DOM中，它也将包含在布局树中。\r\n但是现在有个问题，我们还不知道以什么顺序绘制它们，即不知道谁应该覆盖谁。\r\n![16f0e529b9648654~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp](https://img-blog.csdnimg.cn/img_convert/dafef3f1951a5286d4d574425d505f80.webp?x-oss-process=image/format,png)\r\n**其实很多资料中都会把上面构建渲染树的步骤放到构建布局树的步骤中**\r\n\r\n<a name=\"Hkgqx\"></a>\r\n## 9. 分层、合成层(或者叫update layer tree)\r\n如果我们是首次渲染，那就是分层，如果是更新操作，叫update layer tree。\r\n<a name=\"P2U3P\"></a>\r\n### 9.1 分层\r\n现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？\r\n答案依然是否定的。\r\n因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。\r\n要想直观地理解什么是图层，你可以打开Chrome的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示\r\n<img src='https://img-blog.csdnimg.cn/img_convert/62a593453b1d315f65772bbc4e45f2b9.png'  width=500 />\r\n从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图\r\n<img src='https://img-blog.csdnimg.cn/img_convert/f7407c4db936ecb77cc4d0446526bb27.png' width=300 />\r\n现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：\r\n![](https://img-blog.csdnimg.cn/img_convert/68ea5fdf83d12e10beed07850e529dd7.png)\r\n通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的span标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。\r\n那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。\r\n**第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**\r\n页面是个二维平面，但是层叠上下文能够让HTML元素具有三维概念，这些HTML元素按照自身属性的优先级分布在垂直于这个二维平面的z轴上。你可以结合下图来直观感受下：\r\n![](https://img-blog.csdnimg.cn/img_convert/53fa16551625312f94251278f9b96088.png)\r\n从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用CSS滤镜的元素等，都拥有层叠上下文属性。\r\n**第二点，需要剪裁（clip）的地方也会被创建为图层。**\r\n不过首先你需要了解什么是剪裁，结合下面的HTML代码：\r\n```html\r\n<style>\r\n      div {\r\n            width: 200;\r\n            height: 200;\r\n            overflow:auto;\r\n            background: gray;\r\n        } \r\n</style>\r\n<body>\r\n    <div >\r\n        <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>\r\n        <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>\r\n        <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> \r\n    </div>\r\n</body>\r\n```\r\n在这里我们把div的大小限定为200 * 200像素，而div里面的文字内容比较多，文字所显示的区域肯定会超出200 * 200的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在div区域，下图是运行时的执行结果\r\n![](https://img-blog.csdnimg.cn/img_convert/9c39b265e8863ff8113f3035feba70c8.png)\r\n出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：\r\n![](https://img-blog.csdnimg.cn/img_convert/79fb135283f2884c8fa7d4c0c9109a20.png)\r\n所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。\r\n\r\n\r\n<a name=\"xUQim\"></a>\r\n### 9.2 update layer tree\r\n这一步实际是更新Render Layer的层叠排序关系。\r\n\r\n\r\n\r\n<a name=\"Jf8Hc\"></a>\r\n### 9.3 补充解释：Render Object、Render Layer、Graphics Layer(又称Compositing Layer)和Graphics Context\r\n![a14a6f315f394b0844f7a1ee894593dd~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp](https://img-blog.csdnimg.cn/img_convert/f51627f0d9c827258849ca463ca4c5c7.webp?x-oss-process=image/format,png)\r\n\r\n<a name=\"f1yhZ\"></a>\r\n#### Render Object\r\n首先我们有DOM树，但是DOM树里面的DOM是供给JS/HTML/CSS用的，并不能直接拿过来在页面或者位图里绘制。因此浏览器内部实现了**Render Object**：\r\n**每个Render Object和DOM节点一一对应。Render Object上实现了将其对应的DOM节点绘制进位图的方法，负责绘制这个DOM节点的可见内容如背景、边框、文字内容等等。同时Render Object也是存放在一个树形结构中的。**\r\n既然实现了绘制每个DOM节点的方法，那是不是可以开辟一段位图空间，然后DFS遍历这个新的Render Object树然后执行每个Render Object的绘制方法就可以将DOM绘制进位图了？就像“盖章”一样，把每个Render Object的内容一个个的盖到纸上（类比于此时的位图）是不是就完成了绘制。\r\n不，浏览器还有个层叠上下文的东西。这使得文档流中位置靠前位置的元素有可能覆盖靠后的元素。上述DFS过程只能无脑让文档流靠后的元素覆盖前面元素。\r\n因此，有了Render Layer。\r\n<a name=\"rLAjf\"></a>\r\n#### Render Layer\r\n当然Render Layer的出现并不是简单因为层叠上下文等，比如opacity小于1、比如存在mask等等需要先绘制好内容再对绘制出来的内容做一些统一处理的css效果。\r\n总之就是有层叠、半透明等等情况的元素就会从Render Object提升为Render Layer。不提升为Render Layer的Render Object从属于其父级元素中最近的那个Render Layer。当然根元素HTML自己要提升为Render Layer。\r\n因此现在Render Object树就变成了Render Layer树，每个Render Layer又包含了属于自己layer的Render Object。\r\n现在浏览器渲染引擎遍历 Layer 树，访问每一个 RenderLayer，然后递归遍历negZOrderList里的layer、自己的RenderObject、再递归遍历posZOrderList里的layer。就可以将一颗 Layer树绘制出来。\r\n**Layer 树决定了网页绘制的层次顺序，而从属于 RenderLayer 的 RenderObject 决定了这个 Layer 的内容，所有的 RenderLayer 和 RenderObject 一起就决定了网页在屏幕上最终呈现出来的内容。**\r\n层叠上下文、半透明、mask等等问题通过Render Layer解决了。那么现在:\r\n开辟一个位图空间->不断的绘制Render Layer、覆盖掉较低的Layer->拿给GPU显示出来 是不是就完全ok了？\r\n不。还有GraphicsLayers和Graphics Context\r\n<a name=\"ccQAM\"></a>\r\n#### Graphics Layer(又称Compositing Layer)和Graphics Context\r\n合成层的东西。\r\n上面的过程可以搞定绘制过程。但是浏览器里面经常有动画、video、canvas、3d的css等东西。这意味着页面在有这些元素时，页面显示会经常变动，也就意味着位图会经常变动。每秒60帧的动效里，每次变动都重绘整个位图是很恐怖的性能开销。\r\n因此浏览器为了优化这一过程。引出了Graphics Layers和Graphics Context，前者就是我们常说的**合成层(Compositing Layer)**：\r\n某些具有CSS3的3D transform的元素、在opacity、transform属性上具有动画的元素、硬件加速的canvas和video等等，**这些元素在上一步会提升为Render Layer，而现在他们会提升为合成层Graphics Layer**。每个Render Layer都属于他祖先中最近的那个Graphics Layer。当然根元素HTML自己要提升为Graphics Layer。\r\nRender Layer提升为Graphics Layer的情况：\r\n\r\n- **3D 或透视变换**(perspective、transform) CSS 属性\r\n- 使用加速视频解码的 元素\r\n- 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素\r\n- 混合插件(如 Flash)\r\n- **对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）**\r\n- **will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）**\r\n- 拥有加速 CSS 过滤器的元素\r\n- 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)\r\n\r\n**3D transform、will-change设置为 opacity、transform等 以及 包含opacity、transform的CSS过渡和动画 这3个经常遇到的提升合成层的情况请重点记住。**\r\n所以在元素存在transform、opacity等属性的css animation或者css transition时，动画处理会很高效，这些属性在动画中不需要重绘，只需要重新合成即可。\r\n在前端页面，尤其是在动画过程中，由于 Overlap 重叠导致的合成层提升很容易发生。如果每次都将重叠的顶部 RenderLayer 提升为合成层，那将消耗大量的 CPU 和内存（Webkit 需要给每个合成层分配一个后端存储）。为了避免 “层爆炸” 的发生，浏览器会进行层压缩（Layer Squashing）：如果多个 RenderLayer 和同一个合成层重叠时，这些 RenderLayer 会被压缩至同一个合成层中，也就是位于同一个合成层。但是对于某些特殊情况，浏览器并不能进行层压缩，就会造成创建大量的合成层。\r\n\r\n> RenderObject、 RenderLayer、 GraphicsLayer 是 Webkit 中渲染的基础，其中 RenderLayer 决定了渲染的层级顺序，RenderObject 中存储了每个节点渲染所需要的信息，GraphicsLayer 则使用 GPU 的能力来加速页面的渲染。\r\n\r\n\r\n<a name=\"NrQvq\"></a>\r\n### 使用 合成层提升 减少重绘重排\r\n提升为合成层干什么呢？普通的渲染层普通地渲染，用普通的顺序普通地合成不好吗？非要搞啥特殊待遇！\r\n浏览器就说了：我这也是为了大家共同进步（提升速度）！看那些搞特殊待遇的，都是一些拖我们队伍后腿的(性能开销大)，分开处理，才能保证整个队伍稳定快速的进步！\r\n**特殊待遇**：合成层的位图，会交由 GPU 合成，比 CPU 处理要快。当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层。\r\n\r\n- 对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中\r\n- 对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧\r\n\r\n**通过生成独立的Compositing Layer，让此层内的重绘重排不引起整个页面的重绘重排**\r\n在介绍渲染树的时候提到满足某些条件的 RenderObjectLayer 会被提升为合成层，合成层的绘制是在 GPU 中进行的，比 CPU 的性能更好；如果该合成层需要 Paint，不会影响其他的合成层；一些合成层的动画，不会触发 Layout 和 Paint。\r\n下面介绍几种在开发中常用的合成层提升的方式：\r\n<a name=\"ubRUO\"></a>\r\n#### 使用transform和opacity书写动画\r\n上文提出，如果一个元素使用了 CSS 透明效果的动画或者 CSS 变换的动画，那么它会被提升为合成层。并且这些动画变换实际上是应用在合成层本身上。这些动画的执行过程不需要主线程的参与，在纹理合成前，使用 3D API 对合成层进行变形即可。\r\n```css\r\n#cube {\r\n  transform: translateX(0);\r\n  transition: transform 3s linear;\r\n}\r\n\r\n#cube.move {\r\n  transform: translateX(100px);\r\n}\r\n```\r\n```html\r\n<body>\r\n  <div id=\"button\">点击移动</div>\r\n  <div id=\"cube\"></div>\r\n  <script>\r\n    const btn = document.getElementById('button');\r\n    btn.addEventListener('click', () => {\r\n      const cube = document.getElementById('cube');\r\n      cube.classList = 'move';\r\n    });\r\n  </script>\r\n</body>\r\n```\r\n对于上面的动画，只有在动画开始后，才会进行合成层的提升，动画结束后合成层提升也会消失。这也就避免了浏览器创建大量的合成层造成的 CPU 性能损耗。\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d7d9617507b04cc5b14cbfd56f97c908.webp#pic_center)\r\n\r\n<a name=\"wlQyf\"></a>\r\n#### will-change\r\n这个属性告诉了浏览器，接下来会对某些元素进行一些特殊变换。当 will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left、bottom、right 等需要设置明确的定位属性，如 relative 等），浏览器会将此元素进行合成层提升。在书写过程中，需要避免以下的写法：\r\n```css\r\n*{ will-change: transform, opacity; }\r\n```\r\n这样，所有的元素都会被提升为单独的合成层，造成大量的内存占用。所以需要只针对动画元素设定 will-change，且动画完成之后，需要手动将此属性移除。\r\n<a name=\"i8fG9\"></a>\r\n#### Canvas\r\n使用具有加速的 2D Context 或者 3D Contex 的 Canvas 来完成动画。由于具有独立的合成层，Canvas 的改变不会影响其他合成层的绘制，这种情况对于大型复杂动画（比如 HTML5 游戏）更为适用。此外，也可以设置多个 Canvas 元素，通过合理的Canvas 分层来减少绘制开销。\r\n\r\n\r\n<a name=\"pCFRU\"></a>\r\n## paint(图层绘制)，重绘\r\n**重绘是以合成层为单位的**。\r\n在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？\r\n试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？\r\n**通常，你会把你的绘制操作分解为三步**：\r\n\r\n- 制蓝色背景；\r\n- 在中间绘制一个红色的圆；\r\n- 再在圆上绘制绿色三角形\r\n\r\n渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：\r\n![](https://img-blog.csdnimg.cn/img_convert/e9e2bf0c1969353fe3d62ae4722cb114.png)\r\n从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。\r\n\r\n\r\n其实Paint有两步，第一步是记录要执行哪些绘画调用，第二步才是执行这些绘画调用。第一步只是把所需要进行的操作记录序列化进一个叫做SkPicture的数据结构里，就是上面所说的待绘制列表。\r\n接下来的第二步里会将待绘制列表中的操作replay出来，这里才是将这些操作真正执行：光栅化和填充进位图。主线程中和我们在Timeline中看到的这个Paint其实是Paint的第一步操作。第二步是后续的Rasterize步骤（见后文），其实在Rasterize之前会先分成图块，关于这两个概念的解释在最开始有提到。\r\n> 主线程：生成待绘制列表，交给合成线程\r\n> 合成线程：分成图块，交给栅格化线程\r\n> 栅格化线程：栅格化(生成位图)\r\n> 接着就是将栅格化的结果交给 GPU进程进行draw到浏览器上\r\n> 这里其实有争议，栅格化的结果是直接由栅格化线程交给GPU，还是栅格化线程先将结果交给合成线程，合成线程再把结果交给GPU进程。\r\n\r\n\r\n<a name=\"wtRQp\"></a>\r\n## 分成图块 + 栅格化（raster）操作\r\n绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：\r\n![](https://img-blog.csdnimg.cn/img_convert/2352c9532030c66f0730819354eadc96.png)\r\n如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？\r\n那我们得先来看看什么是视口，你可以参看下图：\r\n![](https://img-blog.csdnimg.cn/img_convert/56fa9a339a5394e98a2d262f33605aa5.png)\r\n通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。\r\n在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\r\n基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是256x256或者512x512，如下图所示：\r\n![](https://img-blog.csdnimg.cn/img_convert/a911076310247ef65903f710fb486961.png)\r\n然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的**。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：\r\n![image.png](https://img-blog.csdnimg.cn/img_convert/5449f15d38e3812758093017c925e47a.png)\r\n通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。\r\n相信你还记得，GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：\r\n![](https://img-blog.csdnimg.cn/img_convert/3565519da12bc5856377cd2f89f499b6.png)\r\n从图中可以看出，渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。\r\n\r\n\r\n\r\n<a name=\"f9ykC\"></a>\r\n## draw\r\nGPU进程把结果draw到浏览器上\r\n\r\n\r\n## 引用\r\n\r\n[https://developer.chrome.com/blog/inside-browser-part3/](https://developer.chrome.com/blog/inside-browser-part3/)\r\n[浏览器渲染详细过程：重绘、重排和 composite 只是冰山一角 - 掘金](https://juejin.cn/post/6844903476506394638#heading-0)\r\n[https://segmentfault.com/a/1190000041295744](https://segmentfault.com/a/1190000041295744)\r\n[https://gist.github.com/paulirish/5d52fb081b3570c81e3a](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)\r\n[渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的 | 浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson06.html#%E6%80%BB%E7%BB%93)\r\n[如何不择手段提升scroll事件的性能](https://zhuanlan.zhihu.com/p/30078937)\r\n[https://github.com/aooy/blog/issues/5](https://github.com/aooy/blog/issues/5)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/2/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1",
    "repository_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io",
    "labels_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1/comments",
    "events_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1/events",
    "html_url": "https://github.com/mengqiuleo/mengqiuleo.github.io/issues/1",
    "id": 2229116650,
    "node_id": "I_kwDOLqkdVs6E3Z7q",
    "number": 1,
    "title": "2023年终总结暨秋招总结",
    "user": {
      "login": "mengqiuleo",
      "id": 85825776,
      "node_id": "MDQ6VXNlcjg1ODI1Nzc2",
      "avatar_url": "https://avatars.githubusercontent.com/u/85825776?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mengqiuleo",
      "html_url": "https://github.com/mengqiuleo",
      "followers_url": "https://api.github.com/users/mengqiuleo/followers",
      "following_url": "https://api.github.com/users/mengqiuleo/following{/other_user}",
      "gists_url": "https://api.github.com/users/mengqiuleo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mengqiuleo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mengqiuleo/subscriptions",
      "organizations_url": "https://api.github.com/users/mengqiuleo/orgs",
      "repos_url": "https://api.github.com/users/mengqiuleo/repos",
      "events_url": "https://api.github.com/users/mengqiuleo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mengqiuleo/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 6788949612,
        "node_id": "LA_kwDOLqkdVs8AAAABlKcmbA",
        "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/labels/%E7%94%9F%E6%B4%BB",
        "name": "生活",
        "color": "fef2c0",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2024-04-06T07:10:06Z",
    "updated_at": "2024-04-06T07:10:06Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "Hello, 这里是小y, 已经12月份了，提前放上今年的年终总结。\r\n\r\n这一年的经历带给我的成长还是很大的，不论在技术上还是在心态上。\r\n\r\n这篇文章刚开始是一些总结，最后放一些我的秋招/学习方面的感悟。\r\n\r\n全文4678词，阅读约12分钟。\r\n\r\n\r\n\r\n# 2023年干了啥？\r\n\r\n## 2月-4月\r\n\r\n今年年初的时候就又开始找工作了，为什么是又？因为去年年底没找到。不过很幸运，今年2月份只花了4天左右就拿到了比较满意的 offer（看来找工作真的需要一些运气）。\r\n\r\n2月多去了成都，那家公司中规中矩吧，技术上没有啥长进，因为是给我单独安排的任务，所以当时我连 Git 协同开发都不怎么会的。不过，在生活方面，我个人还是对成都这个城市满意度比较高的，美食太多了，最后离开成都之前还去看了大熊猫（我个人感觉熊猫都长一个样，我也分不清谁是谁，只觉得熊猫可以分为白的和黄的，就是干净的和不干净的😂）\r\n\r\n在2月多实习的时候，意外的接到了上海一家外企的offer，并且当时也不想在成都那家公司待了，于是三月份飞去了上海。\r\n\r\n上海这家外企很好，965不加班（我甚至到后来都是9:20才到），周一周五居家办公，工作上也是直接参与大家的开发项目，在这里我才真正体验的企业的开发流程，去用 Git 协同开发（mentor人很好，我刚进去 Git 不太会，都是 mentor 教的）, 和后端沟通，开组会。而且薪资也很好。但是技术上其实没啥进步的，因为是外企，本身开发流程就很慢，所以作为实习生也是分配到一些很简单的任务，不过我感觉这是正常的，工作中大部分任务都是增删改查，哪有那么多难点，就算难点很多又怎么会分配给一个实习生做？关于实习心得这块我放到最后聊。\r\n\r\n\r\n\r\n### 关于暑期实习\r\n\r\n3月份同时也是暑期实习火热的时候，当时周围同学以及牛客上很多人都投递了简历，自己觉得不能投晚了，在自己没有准备好的情况下就急忙投递了简历。可是当时因为从成都到上海租房、入职、接触新项目，很长时间没有刷算法，所以算法这块是很虚的，另外还要应付学校老师点名，当时压力很大。最快约面的是美团，一面八股答得都很好，最后算法没写出来挂了，可能这也间接导致面评很差，秋招直接三个志愿全部人才库了。同样，这部分也是最后会聊。暑期实习简历投递半个多月后，我没有收到什么面试，基本都是笔试挂。另外，学校那边瞒不下去了，最迟4月底回学校，当时决定：放弃暑期实习！在学校好好准备一下，6月份重新找一份实习，虽然上海这段实习时间有点短，放在简历上不好看，但是也没办法了。\r\n\r\n就这样，我每天白天上班，晚上回家去想办法参与一些开源。转眼间到了4月底，我准备辞了上海的实习，结果 leader 允许我请一个月假😊。正好不用找工作了，自己有大把时间去参与开源了。\r\n\r\n\r\n\r\n## 5月-8月\r\n\r\n5月份去了校企定制实习，感觉上海的实习好像打通了任督二脉，这一个月进步很大(所以我现在非常建议去实习，实习学到的东西比自己学到的要多得多)，自己造了个小轮子，写了个树组件，学习了mini-vue，完善了项目啥的，也去主动争取了一些开源，参加了“开源之夏”，6月到8月就是按部就班的上班，晚上回去学习一会儿，参与一些开源啥的。\r\n\r\n原本定的是9月底回学校，但是8月份的时候秋招已经开了很多了，自己感觉实习没有什么收获了，于是辞去实习专心准备秋招了，8月15号正式投出第一份简历，第一个面试是快手给的，8月底速通三面，进池子泡着，同时8月也收到一些笔试，但是都没有结果。\r\n\r\n\r\n\r\n## 9月-12月\r\n\r\n整个9月是过的比较煎熬的，9月中旬应该是秋招最火热的时候，而自己却坐了冷板凳，眼看着美团三个志愿全部人才库，甚至腾讯云智都简历挂了...整个9月就是收到一些笔试或者感谢信，每天在图书馆坐一天，也没学到啥东西，9月底到十月初约到了几家面试，但是不幸的是很多最后都泡池子挂了，或者被KPI面了。\r\n\r\n直到10月中旬的时候我的秋招依然没有任何结果，当时有点蚌埠住了，就开始摆烂了，10月底拿到了数字马力的意向，算是有个保底吧，但还是心有不甘，我努力了这么长时间，却只拿到了这样一个结果，不甘心啊...11月初我比较中意的一家小厂约了hr面，也顺利通过了，同时被字节捞了，但是三面挂了，算法没写出来，不过无所谓了，准备和那家中意的小厂签三方了。\r\n\r\n11月中下旬三方签约完毕，摆烂开始，11月底考了科目二，100分。但是科目三考试的时间到12月下旬了，太晚了，驾照在我这里只能当做支线任务😂，剩下的明年毕业论文的时候半个月搞定就行。\r\n\r\n12月初把学校这边的旅游景点逛了个遍，最近准备去公司实习去了(本来还想去逛，奈何身上钱不够，去实习攒点)，在北京实习，周六日就把北京逛得差不多了，如果有时间，顺手去趟天津。\r\n\r\n现在最希望的是，顺利度过试用期，公司多挣点钱，这样我才不会被裁员。\r\n\r\n\r\n\r\n\r\n\r\n# 秋招心得\r\n\r\n先列一下数据：\r\n\r\n- 双非二本，一段外企实习(不太被 hr 认可)，一段开源经历，两个小的编程比赛(蓝桥杯，天梯赛，没用的)，一个访问量40w+的CSDN博客，提交次数还不错的github，两个自己的玩具项目\r\n\r\n- 官网投递150家左右，BOSS上沟通280家投出去十几份，因为后期还在BOSS上沟通过实习，所以BOSS上秋招投出去的简历估计不过十份。\r\n- 收到笔试大概20多家，拿到面试机会只有8家，最后给明确意向的只有两家，KPI一家，主动放弃的一家，泡池子排序挂的三家\r\n\r\n我觉得，一份简历 = 学校 + 专业技能 + 实习 + 项目 + 开源(可有可无) + 竞赛(影响力一般)\r\n\r\n学校已成定局，专业技能好好改改，大家都写的差不多，专业技能又不能写出花来。\r\n\r\n实习占比 >>> 项目\r\n\r\n\r\n\r\n## 实习方面\r\n\r\n能去大厂就去大厂！！！对于学历不好的同学，我们只是需要这一个牌子，至于进去干什么，实习生的难点能有多难，面试官只是希望你把接到的这个需求说清楚，拿到这个需求如何分析，给出什么方案，只有这一种方案吗，为什么选择这种方案，相对于其他方案好在哪？\r\n\r\n至于外企，好又不好，很轻松，自己可以实习秋招两手抓，我也是在外企实习，但是面试的时候，很多HR都不认识，很影响最后排序结果，甚至在简历初筛的时候就会有影响，举一个例子：我最开始投递快手的时候，两次简历初筛挂，后来在公司后面备注了一个外企，结果第三次简历初筛就过了。\r\n\r\n所以如果接到外企的实习，如果这个名字很陌生，慎重，985、211随意。\r\n\r\n\r\n\r\n对于双非同学来说，最好在秋招之前能有一段叫得上名字的厂的实习，甚至在9,10月份拿到大厂实习但是与秋招冲突的情况下也要去实习。在我意识到自己的实习经历不太行的时候，已经十月中旬了，我再去BOSS上沟通实习，大厂都不要，只收25届的了，想去实习也去不了。\r\n\r\n\r\n\r\n以我的经验来看，秋招提前批如果 有大厂实习的话，双非约面的概率还挺大的。\r\n\r\n进入秋招，如果没有大厂实习，双非同学估计整个9月份是没有消息的，双非是金十银十一，所以这也是为什么建议双非同学在9月份拿了大厂实习也要去。\r\n\r\n\r\n\r\n\r\n\r\n### 实习工作内容方面\r\n\r\n最好可以记录下自己每天干了什么。\r\n\r\n实习生的难点又能有多难，我觉得最理想的实习状态是和周围的同事共同维护一个项目，这样至少可以学习一下协同开发。如果实习真的干的打杂的活，很难往简历上写，不如去看看周围同事的代码提交，“看懂了就是我的”。\r\n\r\n如果实习是让自己写一个东西，比如我第一次实习就是单独给公司内部写个简单的后台管理系统，我面暑期实习的时候，美团的面试官问了我实习期间大概干了什么之后，也没有针对实习问些问题了。这种实习情况下，我也不知道怎么办了😂，我当时是直接走了。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 实习投递时间\r\n\r\n关于暑期实习，我自己在2月初的时候找到了一份日常实习，所以暑期实习并没有太上心，一方面是有日常实习保底，另一方面是抽不出时间。\r\n\r\n2月初的时候去找日常实习要比卷暑期实习容易的多，如果找到了大厂的日常实习，那最后秋招的时候简历上写的都一样，又不会区分是日常还是暑期。但另一方面暑期实习可以转正，以目前的形式来看，转正这个事情其实也说不准的，美团今年原则上是应转尽转，但是我也在牛客上见过几个转正失败的。\r\n\r\n所以，是提前找一个日常还是等到3月份卷暑期，权衡一下。\r\n\r\n\r\n\r\n### 秋招投递时间\r\n\r\n准备的差不多就可以投了，比如觉得自己八股还不太行，算法还不太行，没关系，投递，最好能赶上第一批简历处理。\r\n\r\n从投递到面试还有一段时间呢，如果说觉得自己算法不行，怕笔试过不去，额，还是投递，笔试出的题目和 力扣hot100，区别挺大的，短时间内算法是提升不了的。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 项目方面\r\n\r\n应届生的项目感觉就是个玩具，\r\n\r\n往项目里面增加亮点，我常用的思路：把自己的项目数据量放大，比如后台管理项目，当时我的项目里面加上超级管理员才5,6个人，连分页组件都用不上... 因此可以反过来想，我的项目可以放到真实的企业中用吗，当然不能，为什么不能？\r\n\r\n自己的项目逻辑简单，那就搞复杂点的需求，前端打印，大文件上传，大文件上传优化，虚拟滚动，登录无痛刷新，组件二次封装(封装要注意什么，我会认为如果原本组件的API很多不能直接使用，而是无缘无故的增加很多API，这样是不太好的，仅个人想法)，前端测试...\r\n\r\n或者还有另外一个角度考虑：自己的项目写完了，得部署吧，总不能让面试官跑 localhost 吧，部署又涉及到了自动化部署，不能每次修改代码都手动部署吧，部署上去发现访问慢的要死，得性能优化吧，打包优化又涉及到了webpack，关于优化去掘金上搜搜，一搜一大把...\r\n\r\n或者还有一个骚操作，就是 直接搜 “项目名”+ 难点 或者 “技术栈”+ 难点，去抄别人的难点。\r\n\r\n\r\n\r\n\r\n\r\n## 算法方面\r\n\r\n我水平一般，面试的时候，一般只考 力扣hot100，加上手写题，理解了之后，背就完了，我不会在这方面花很多时间，我感觉算法付出和收益不成正比。\r\n\r\n笔试的时候，随缘吧。而且现在有 ChatGPT，就算自己是正人君子，那别人呢？\r\n\r\n\r\n\r\n### 关于竞赛\r\n\r\nACM不用说，很强，但是又有多少人能拿到名次呢？\r\n\r\n常见的就是蓝桥杯、天梯赛、全国大学生编程比赛啥的，以我的经验来看，没什么用，没一段实习经验来的扎实。\r\n\r\n而且打比赛真的很浪费时间，这几个月去打比赛，还不如去学前端，提前去实习呢。\r\n\r\n\r\n\r\n\r\n\r\n## 开源方面\r\n\r\n开源真的挺占分量的，我感觉我的简历上因为有了开源，才收到了一些面试的，而且开源也能和面试官聊一会儿。\r\n\r\n我建议大家可以参与一下“开源之夏”，挺不错的，或者去 掘金 - 沸点 - 加入 “优秀开源项目”圈子，里面会有人把自己的项目开源，可以去挑一挑。\r\n\r\n开源急不得，估计得很长时间才能找到一个合适的开源项目。\r\n\r\n如果因为学校原因，不能去实习，可以尝试去开源一下。\r\n\r\n\r\n\r\n## 面试 + 投递 方面\r\n\r\n无脑海投，over\r\n\r\n但是注意在 BOSS 上投的时候，招呼语最好前几个字就展示自己的亮点，因为hr不打开的时候只能看见前几个字的，比如我的：您好，一段外企实习，参与过开源...\r\n\r\n\r\n\r\n面试不要怕，面试不过就不过呗，反正这辈子估计就见这一面。\r\n\r\n自我介绍好好想想，最好有点亮点，面试官可以针对自我介绍问些想问的，而这些东西都是自己已经想好的，如果真的问了，那这不就是开始吟唱...\r\n\r\n\r\n\r\n### 八股文\r\n\r\n八股文答案都一样，但是可以想想怎么给八股背出花来，如果问到了，又是开始吟唱。\r\n\r\n对于一些非常常见的面试题，我一般都会自己扩充，\r\n\r\neg:\r\n\r\n- vue2 VS vue3, 可以往vue3的编译优化方面说说，patchFlag，静态节点提升，BlockTree收集dynamicChildren\r\n- 响应式：什么是响应式？vue2 的 缺点，在没有 vue3 之前是如何解决的？这些解决方案的原理？vue3 如何升级、解决的？响应式是如何和组件(页面)更新联系起来的？\r\n- vue diff：为什么会有 diff 算法？真实DOM为什么会消耗性能？之后说双端diff和全量diff\r\n- XSS：除了常规的，往 vue  和 react 针对 XSS 处理方面说说\r\n- https加密：除了三个随机数那种方法，再说说椭圆曲线那种方式\r\n- 输入url的渲染过程：这部分内容还是挺多的，推荐：[浏览器渲染详细过程：重绘、重排和 composite 只是冰山一角](https://juejin.cn/post/6844903476506394638#heading-0), 可以从这篇文章入手，再去找找其他类似的文章\r\n- 事件循环：js 单线程，为什么是单线程？同步任务、异步任务，宏任务、微任务，再加上浏览器更新，加上 nextTick\r\n- 闭包：什么是闭包？闭包的好处？使用场景？内存泄漏？内存溢出？\r\n- 七层网络模型：详细再详细，当时字节三面这个题被面试官吊打，一问三不知\r\n\r\n\r\n\r\n## 心态方面\r\n\r\n有时候肯定会蚌埠住了，没办法，只有坚持，如果真的已经两个多月了，在自己已经非常努力的情况下，颗粒无收的话，要不出去走走吧，去庙里拜拜，说不定运气就好了。肯定会有时来运转的时候，请等待。\r\n\r\n或者也看命？我从来没进过大厂，但是我总能找到那种小而美的厂，而且工资也不错的，也不卷，可能这就是命吧。\r\n\r\n\r\n\r\n\r\n\r\n「但因热爱，愿迎万难」\r\n\r\n祝大家工作顺利！\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/mengqiuleo/mengqiuleo.github.io/issues/1/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
