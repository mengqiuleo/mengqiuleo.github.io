# [聊一聊小票打印](https://github.com/mengqiuleo/mengqiuleo.github.io/issues/10)

这里涉及到的业务是 electron 实现小票打印。



小票打印的实现方案主要有两种，

第一种是调用 electron 自带的 print 方法进行打印，思路与浏览器原生 API 打印的实现相同，我们创建一个新的窗口，在这个窗口中画出要打印的内容，然后调用 `printWindow.webContents.print` 方法打印这个窗口的内容。

第二种是调用 ESC/POS 指令，目前市面上大部分打印机均支持该指令，我们可以通过该指令控制打印内容及打印样式。且 ESC/POS 指令应该是大部分小票打印的主流实现方式，第一种方案虽然也可以实现，但打印效果（字体清晰度，排版）并不好，并且在我这边还出现了上下左右边距在不同的打印机上不一致的问题。





这里不介绍第一种方案的实现，网上文章比较多，个人感觉这种实现并不太靠谱，除了上面说的样式问题，个人感觉最大的坑点是：一些配置不生效，从网上直接拿过来的方案不能直接运行，最后排查是某些参数没有加，并且我配置的一些参数貌似不生效 or 不需要。





关于 ESC/POS 指令的实现，这里先推荐一些关于热敏打印机的知识及相关实现方案：

1. [https://www.cnblogs.com/MrDing/category/627839.html](https://www.cnblogs.com/MrDing/category/627839.html)
2. [https://juejin.cn/post/7297529039312158730](https://juejin.cn/post/7297529039312158730)
3. [https://juejin.cn/post/6844903734573531150](https://juejin.cn/post/6844903734573531150)
4. [https://juejin.cn/post/6844903893873197064](https://juejin.cn/post/6844903893873197064)





个人感觉[《古茗打印机技术的演进》](https://juejin.cn/post/7297529039312158730)这篇文章已经写的很好了，这里主要是对该文章的解读以及聊一下实践遇到的问题。





## 整体思路

> <font style="color:rgb(0, 0, 0);">打印机驱动的作用其实相当于“翻译”，电脑要想通过打印机打出图像和文字，两者之间就必须使用统一的“语言”沟通，打印机驱动就是将计算机想要说的话按照约定的标准（例如ESC/POS指令）“翻译”成打印机能识别的语言。</font>

<font style="color:rgb(0, 0, 0);">上面提到的 electron 新建窗口打印，其实就相当于我们告诉打印机驱动要打印什么东西，然后打印机驱动“翻译”并发送给打印机。</font>

而 ESC/POS 指令打印，相当于我们直接向打印机发送翻译后的内容。



注：我们这里只讨论 USB 连接的打印机，串口打印机类似。



**整体思路**：整体分两步走，第一步，我们将打印的内容翻译为 ESC/POS 指令，第二步，找到打印机在哪个 USB 接口，并将数据传输给该 USB 接口。





<h3 id="Yha1u">ESC/POS 指令封装</h3>

这个网上有现成的库，但是根据业务需要，还需要自定义封装一些指令，索性就自己全封装了（其实是直接对别人封装好的进行二次封装，指路：[https://github.com/Freeman8612/escpos-printer](https://github.com/Freeman8612/escpos-printer)）

<font style="color:rgb(0, 0, 0);"></font>

<font style="color:rgb(0, 0, 0);">指令集封装过程中，遇到的一个问题是「对条码的封装」</font>

<font style="color:rgb(0, 0, 0);">条码类型很多，比如 CODE128，CODE39，EAN13...</font>

<font style="color:rgb(0, 0, 0);">我这里打印的是自定义的条码，均为数字，长度为 16位。所以就选择了 CODE128</font>

<font style="color:rgb(0, 0, 0);"></font>

<img width="894" height="921" alt="Image" src="https://github.com/user-attachments/assets/0a28feb3-2dca-449e-a7b1-7e22a51d2d8f" />



参考上图的指令说明，我们可以得到以下封装方法：

```javascript
/**
 * 打印订单号条码（CODE128） 8,73 为CODE128  4,69 为CODE39
 *
 * @param {String} code 订单号，如 "2025101900000016"
 * @return {Command}
 */
barcodeOrderNo(code) {
  code = String(code);
  console.log(code);
  this._queue.push(...this._cmd["ESA"], 1);

  // 条码宽度 1
  this._queue.push(0x1d, 0x77, 2);
  // 条码高度 60 dots
  this._queue.push(0x1d, 0x68, 70);

  this._queue.push(...this._cmd["GSH"], 2);
  // this._queue.push(...this._cmd["GSK"], 8, ...Command.transformNumberToBarcode(code), 0x00);
  this._queue.push(...this._cmd["GSK"], 73, code.length, ...code.split("").map(c => c.charCodeAt(0)));

  this._queue.push(...this._cmd["ESA"], 0);
  return this;
}
```

<font style="color:rgb(0, 0, 0);"></font>

**<font style="color:rgb(0, 0, 0);">遇到的问题：条码数字过长，导致超过了小票有限宽度，则打印机打印不出来。（可以自测打印 123456789 和 2025101900000016 进行对比）</font>**

**<font style="color:rgb(0, 0, 0);"></font>**

<font style="color:rgb(0, 0, 0);">解决：</font>

<font style="color:rgb(0, 0, 0);">不直接通过指令打印条码，而是先将条码生成图片，并转化为 base64 再进行打印</font>

```javascript
const imgBuffer = Buffer.from(orderData.orderNoBase64.replace(/^data:image\/\w+;base64,/, ""), "base64");
await cmd.image(imgBuffer, "image/png") // 打印条码图片
```

```javascript
export function generateBarcodeBase64(orderNo: string) {
  const canvas = document.createElement("canvas");

  JsBarcode(canvas, orderNo, {
    format: "CODE128",   // 推荐 CODE128
    displayValue: true,  // 显示一维码下方的文字
    fontSize: 26, // 16 26 设置条形码文本的字体大小
    height: 90, // 50  90 指定条形码高度
    width: 2, // 指定条形码中单条竖线的宽度
  });

  return canvas.toDataURL("image/png");
}
```

<font style="color:rgb(0, 0, 0);"></font>

<font style="color:rgb(0, 0, 0);"></font>

### 对指定 USB 口进行数据传输

<font style="color:rgb(0, 0, 0);">参考古茗的实现方案：</font>

1. 找到 USB 设备列表（这里调用 [node-escpos-win](https://www.npmjs.com/package/node-escpos-win)）
2. 获取打印机驱动列表
3. 获取 USB 的「端口:路径」映射
4. 根据用户选择的打印机名称，从打印机驱动列表中拿到对应的打印机，然后找到该打印机的「端口:路径」映射，再将该映射与 USB 设备列表匹配，找到指定的 USB 设备路径
5. 向该 USB 设备发送 ESC/POS 指令





<h4 id="iK1jJ">找到 USB 设备列表</h4>

```javascript
import escpos from 'node-escpos-win';

const usb = escpos.GetDeviceList('USB');
const usbList = usb.list.filter(
  (item: any) => item.service === 'usbprint' || item.name === 'USB 打印支持'
);
```



<font style="color:rgb(0, 0, 0);"></font>

<h4 id="i653R"><font style="color:rgb(0, 0, 0);">获取打印机驱动列表</font></h4>

打印机驱动中可以看到当前打印机所在的 USB 端口，如图所示：  

![Image](https://github.com/user-attachments/assets/df3ed2b0-f8ea-4877-a867-25ccf7bfde5b)

当前打印机所在端口为 USB001





获取打印机驱动列表的实现方式有多种，古茗选择了 `wmic-js`这个 npm 包，但是我本地执行时直接报错，提示字符编码不同，于是换成了用 `win32-printer`npm 包来获取。但`win32-printer`在 CICD 执行时报错（云端构建采用的镜像为 `electronuserland/builder:wine`）。这个问题没深究，既然可以通过`wmic-js`npm 包来实现，那么原生的 wmic 命令也是可以的。

这里把三种实现方式都列举一下。

**wmic-js**

```javascript
// 获取打印机驱动的信息
export const getPrinter = () => {
  const wmic = require('wmic-js');
  return new Promise<Printer[]>((res, rej) => {
    wmic()
      .alias('printer')
      .get('Name', 'printerState', 'printerStatus', 'WorkOffline', 'PortName')
      .then((data: Printer[]) => {
        res(data);
      })
      .catch((err: unknown) => {
        rej(err);
      });
  });
}
```



**win32-printer**

```javascript
export const getPrinters = (): Printer[] => {
  const printer = require('win32-printer');
  const printers = printer.getPrinters();

  return printers.map((p: any) => ({
    Name: p.name,
    PortName: p.portName,
    WorkOffline: p.attributes.offline,
    printerState: p.status,
    printerStatus: p.status,
  }));
};
```



**wmic 命令**

```javascript
export const getPrinterList = (): Promise<PrinterInfo[]> => {
  return new Promise((resolve, reject) => {
    const cmd = `wmic printer get Name,PortName,WorkOffline,PrinterStatus,PrinterState /format:list`;

    exec(cmd, { encoding: 'utf8' }, (err, stdout) => {
      if (err) return reject(err);

      // console.log('wmic printer stdout:', stdout);
      const printers: PrinterInfo[] = [];
      let current: Record<string, string> = {};

      stdout.split(/\r?\n/).forEach(line => {
        line = line.trim();
        if (!line) return; // 跳过空行

        const [k, v] = line.split('=');
        if (!k) return;

        if (k === 'Name') {
          // 遇到新的 Name，就把上一个 current 保存
          if (current.Name) {
            printers.push({
              Name: current.Name,
              PortName: current.PortName,
              WorkOffline: current.WorkOffline,
              PrinterStatus: current.PrinterStatus,
              PrinterState: current.PrinterState
            });
            current = {};
          }
        }
        current[k.trim()] = (v ?? '').trim();
      });

      // 最后一条
      if (current.Name) {
        printers.push({
          Name: current.Name,
          PortName: current.PortName,
          WorkOffline: current.WorkOffline,
          PrinterStatus: current.PrinterStatus,
          PrinterState: current.PrinterState
        });
      }

      resolve(printers);
    });
  });
};

```



<h4 id="O0khl">获取 USB 的「端口:路径」映射</h4>

```typescript
export const printPortMap = () => {
  return new Promise<Record<string, string>>((res, rej) => {
    exec('wmic path Win32_USBControllerDevice get Dependent /format:list', (err, stdout) => {
      if (err) {
        rej(err);
        return;
      }
      const usbList: string[] = [];
      const map: Record<string, string> = {};
      const lines = stdout.split('\r\r\n');

      lines.forEach((line: any) => {
        if (line.startsWith('Dependent=')) {
          const usb = line.replace('Dependent=', '');
          usbList.push(usb);
        }
      });
      for (let i = 0; i < usbList.length; i++) {
        if (usbList[i].indexOf('USBPRINT') > -1) {
          const line = usbList[i].replace(/"/g, '');
          const portName = line.substr(line.length - 6);
          const usbPath = usbList[i - 1].replace(/&amp;/g, '&');
          if (portName.indexOf('USB') > -1) {

            console.log('usbPath', usbPath);
            // 将 DeviceID 中的格式转换成 usbList 里格式（都转小写匹配）
            const normalizedUsbPath = usbPath
              .toLowerCase()
              .replace(/\\/g, '#') // USB\VID_0483&PID_070B\4F3CC8100303 -> usb#vid_0483&pid_070b#4f3cc8100303
              .replace(/^usb#/, ''); // 有的 usbList 没有 usb# 开头

            map[portName] = normalizedUsbPath;
          }
        }
      }
      res(map);
    });
  });
};
```







<h4 id="qzsjG">找到指定的 USB 设备路径</h4>

```typescript
function extractUsbId(str) {
  if (typeof str !== 'string') return null;
  const match = str.match(/usb#vid_[0-9a-f]+&pid_[0-9a-f]+#[^"#\\]+/i);
  return match ? match[0].toLowerCase() : null;
}
function isUsbDeviceMatch(devicePath, portMapString) { // 这里主要匹配的是 pid 和 vid
  const idFromPath = extractUsbId(devicePath);
  const idFromPortMap = extractUsbId(portMapString);
  return idFromPath && idFromPortMap && idFromPath === idFromPortMap;
}

printList.forEach((printItem: any) => {
    if (printItem.Name === printerName) {
      const usbDevice = usbList.find((useItem: any) => {
        return isUsbDeviceMatch(useItem.path, portMap[printItem.PortName]);
      })

      const res = escpos.Print(usbDevice.path, buffer);
      // console.log('打印结果', res); // 打印结果 { success: 1, err: 0 }
      escpos.Disconnect(usbDevice.path);

      callback(res)
    }
  })
```




<font style="background-color:#FBDE28;">pid 和 vid:</font>

 在 USB 设备的上下文中，  `PID` 和 `VID` 用于唯一识别设备  

VID: 标识设备的**制造商**是谁。每个注册厂商一个唯一的 VID。

+ **例如：**
  - `0x046D` → Logitech（罗技）
  - `0x04E8` → Samsung（三星）
  - `0x05AC` → Apple（苹果）
  - `0x2C7C` → Quectel（移远通信）

PID: 标识该厂商旗下的**具体产品型号**。由厂商自己定义（与其 VID 搭配使用）。

+ **例如：**
  - VID:PID = `046D:C52B` → 罗技无线接收器
  - VID:PID = `05AC:12A8` → iPhone（USB 连接模式）
  - VID:PID = `2C7C:0125` → Quectel EC25 4G 模块









<h2 id="W0lgM">构建部署细节</h2>
<h3 id="xkP38">本地构建 node-escpos-win is not a valid Win32 application</h3>

本地执行没什么问题，非常丝滑。但是首次尝试本地构建使用报错了（当时本地构建的是 32 位的 exe）：

![Image](https://github.com/user-attachments/assets/6fae013e-0fba-4584-a774-bb194e3e9aa7)



从错误语义上，说明 node-escpos-win 不是一个 32位的包。

排查及解决：

1. 本地安装依赖时执行的是`npm i node-escpos-win`，由于电脑是 64 位的，那么安装的依赖自然是 32位的。
2. 那么自然而然，解决方案为构建一个 32 位的包，命令如下：

```typescript
- cd node_modules/node-escpos-win
- node-gyp clean configure build --target=31.7.7 --arch=ia32 --dist-url=https://electronjs.org/headers --verbose
- cd ../../
```

3. 然后再次执行本地构建命令，打包后的 exe 可正常执行
4. 那么云端构建自然也是将这些命令加入脚本即可



但经过一番操作，云端构建确实成功了，但是发布的 exe 却没法用，依然报错：.node is not a valid Win32 application.

另外还有一个问题时，在我本地打包后，此时执行`npm run dev`，也报错了，依然是相同的错误，但 `node-escpos-win`这个包已经是 32 位的啊。



**问题定位：**

**这个报错有点具有迷惑性，当 Electron 和 npm 包架构对不上时都会报这个错，不一定是指这个 npm 包不是 32 位的。**

我的 electron 是 64 位的。可以通过以下命令检查：

```typescript
console.log("Electron process.arch =", process.arch); // Electron process.arch = x64
```



node-escpos-win 这个包是 32 位的。可以通过以下命令检查：

```typescript
lenovo@LAPTOP-D59IOVE5 MINGW64 /e/pos (dev)
$ file node_modules/node-escpos-win/build/Release/*.node
node_modules/node-escpos-win/build/Release/addon.node: PE32 executable (DLL) (GUI) Intel 80386, for MS Windows, 5 sections
```



那么此时的解决方案就很清晰了：

1. 把本地 electron  架构换成 32 位的（其实不太合适...）
2. 本地装 node-escpos-win npm 包时，本地开发手动构建为 64 位，本地构建自测时手动构建为 32 位，下次本地开发之前又手动构建成 64 位的（这个方案非常不合适...）





云端构建报错的原因（云端镜像为`electronuserland/builder:wine`）：

将构建的 asar 反编译，对该`.node`依赖检测是否为 32 位的包。

```typescript
lenovo@LAPTOP-D59IOVE5 MINGW64 /d/exe/resources/unpacked_app
$ file node_modules/node-escpos-win/build/Release/*.node
node_modules/node-escpos-win/build/Release/addon.node: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=f8b227b2a45bfa6372468de5816bc2fe9fbfad6c, not stripped
```

`.node` 文件 **是 Linux 的 ELF 格式**，而不是 Windows 的 PE（Portable Executable）格式





既然云端构建不行，本地也要多次构建，那么为什么不绕过`node-escpos-win npm 包`，我本地对源文件编译得到 `.node`依赖，然后项目中引入该 `.node`依赖呢？

这种方案的缺点就是当本地 electron 的版本变更后，需要根据新的 electron 版本进行重新构建和引入。





本来想的是自己根据 node-escpos-win 的源码，自己翻译成 rust 版本，然后利用 naip-rs 生成 .node 依赖。但这种方法显然不是最优解。最后查找到「我们用 npm 包下载的依赖，也是可以用 node-gyp 进行二次编译的」



<h3 id="jidKu">引入原生  .node 依赖</h3>

在`node_modules/node-escpos-win`目录下分别执行构建命令：

```typescript
node-gyp clean configure build --target=31.7.7 --arch=ia32 --dist-url=https://electronjs.org/headers --verbose
node-gyp clean configure build --target=31.7.7 --arch=x64 --dist-url=https://electronjs.org/headers --verbose
```

查看`node_modules/node-escpos-win/build/Release`目录，可以分别得到 32位 和 64位的 `.node`





**项目中引入**

```typescript
import fs from 'fs';
import path from 'path';
import { createRequire } from 'module';
import { fileURLToPath } from 'url';

const requireCjs = createRequire(import.meta.url);
// ESM 中获取 __dirname
const __dirname = path.dirname(fileURLToPath(import.meta.url));

export function loadEscpos() {
  if (process.platform !== 'win32') {
    throw new Error(`Unsupported platform: ${process.platform}`);
  }

  let archFolder;
  switch (process.arch) {
    case 'ia32':
      archFolder = 'win32-ia32';
      break;
    case 'x64':
      archFolder = 'win32-x64';
      break;
    default:
      throw new Error(`Unsupported architecture: ${process.arch}`);
  }

  const addonPath = path.join(__dirname, '../../', 'native', 'node-escpos-win', archFolder, 'addon.node');

  if (!fs.existsSync(addonPath)) {
    throw new Error(`Native module not found: ${addonPath}`);
  }

  console.log(`Loading escpos native module: ${addonPath}`);
  return requireCjs(addonPath);
}

// 使用
// import { loadEscpos } from './load-escpos-win.mjs';
// const escpos = loadEscpos();
```



原生依赖存放位置：项目根目录下`native/node-escpos-win/win32-ia32/addon.node`和`native/node-escpos-win/win32-x64/addon.node`



注意，原生依赖不应该打包进 asar，需要对配置文件做处理：

```typescript
asarUnpack:
  - resources/**
  - native/**/*
```


<br /><br />



至此，escpos 指令的打印及构建就结束了。可能还有拓展的地方是对小票模板的编辑，这个有点类似于低代码，设计一套 DSL 就行。